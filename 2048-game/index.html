–ü–µ—Ä–µ–π—Ç–∏ –∫ —Å–æ–¥–µ—Ä–∂–∏–º–æ–º—É
–ò—Å—Ç–æ—Ä–∏—è —á–∞—Ç–∞


–í—ã —Å–∫–∞–∑–∞–ª–∏:
'use client';

import { useState, useEffect, useCallback, useRef } from 'react';
import { useFirebase, useUser, useDoc, useMemoFirebase } from '@/firebase';
import { doc, collection, addDoc, serverTimestamp } from 'firebase/firestore';
import { signInAnonymously } from 'firebase/auth';
import { setDocumentNonBlocking } from '@/firebase/non-blocking-updates';
import { profanityFilter } from '@/lib/profanity-filter';
import { cn } from '@/lib/utils';
import GameHeader from '@/components/game/GameHeader';
import GameControls from '@/components/game/GameControls';
import GameModal from '@/components/game/GameModal';
import NicknameModal from '@/components/game/NicknameModal';

// --- Types from src/lib/game-types.ts ---
export type Tile = {
  id: number;
  value: number;
  row: number;
  col: number;
  isNew?: boolean;
  isMerged?: boolean;
};
export type GameState = 'playing' | 'won' | 'lost';
export type Theme = 'beige' | 'dark' | 'ocean' | 'forest';
export type PlayerProfile = {
  id: string;
  nickname: string;
  themePreference: Theme;
};

// --- Tile component from src/components/game/Tile.tsx ---
const tileColorClasses: { [key: number]: string } = {
  2: 'bg-[var(--tile-2)] text-[var(--tile-text-dark)]',
  4: 'bg-[var(--tile-4)] text-[var(--tile-text-dark)]',
  8: 'bg-[var(--tile-8)] text-[var(--tile-text-light)]',
  16: 'bg-[var(--tile-16)] text-[var(--tile-text-light)]',
  32: 'bg-[var(--tile-32)] text-[var(--tile-text-light)]',
  64: 'bg-[var(--tile-64)] text-[var(--tile-text-light)]',
  128: 'bg-[var(--tile-128)] text-[var(--tile-text-light)]',
  256: 'bg-[var(--tile-256)] text-[var(--tile-text-light)]',
  512: 'bg-[var(--tile-512)] text-[var(--tile-text-light)]',
  1024: 'bg-[var(--tile-1024)] text-[var(--tile-text-light)]',
  2048: 'bg-[var(--tile-2048)] text-[var(--tile-text-light)] relative overflow-hidden',
  4096: 'bg-[var(--tile-super)] text-[var(--tile-text-light)]',
  8192: 'bg-[var(--tile-super)] text-[var(--tile-text-light)]',
};

const fontSizeClasses: { [key: number]: string } = {
  2: 'text-4xl md:text-5xl',
  4: 'text-4xl md:text-5xl',
  8: 'text-4xl md:text-5xl',
  16: 'text-3xl md:text-4xl',
  32: 'text-3xl md:text-4xl',
  64: 'text-3xl md:text-4xl',
  128: 'text-2xl md:text-3xl',
  256: 'text-2xl md:text-3xl',
  512: 'text-2xl md:text-3xl',
  1024: 'text-xl md:text-2xl',
  2048: 'text-xl md:text-2xl',
  4096: 'text-lg md:text-xl',
  8192: 'text-lg md:text-xl',
};

function TileComponent({ value, row, col, isNew, isMerged }: Tile) {
  const colorClass = tileColorClasses[value] || 'bg-[var(--tile-super)] text-[var(--tile-text-light)]';
  const fontClass = fontSizeClasses[value] || 'text-md';

  const style = {
    '--x': col,
    '--y': row,
    transform: translate(calc(var(--x) * (100% + 10px)), calc(var(--y) * (100% + 10px))),
    zIndex: isMerged ? 20 : 10,
  } as React.CSSProperties;

  return (
    <div
      className={cn(
        'absolute rounded-md flex items-center justify-center font-black select-none',
        'w-[calc(25%-7.5px)] h-[calc(25%-7.5px)]',
        'transition-transform duration-100 ease-in-out',
        colorClass,
        fontClass,
        isNew && 'animate-fade-in',
        isMerged && 'animate-pop',
        value === 0 && 'hidden',
        value === 2048 && 'animate-pulse-2048'
      )}
      style={style}
    >
      {value === 2048 && <div className="absolute inset-0 rainbow-border" />}
      { value > 0 && <span className="relative">{value}</span> }
    </div>
  );
}

// --- GameBoard component from src/components/game/GameBoard.tsx ---
const BOARD_SIZE = 4;

function GameBoard({ tiles, onMove }: { tiles: Tile[], onMove: (direction: 'up' | 'down' | 'left' | 'right') => void }) {
  const boardRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const boardEl = boardRef.current;
    if (!boardEl) return;

    let touchStartX = 0;
    let touchStartY = 0;
    const SWIPE_THRESHOLD = 30;

    const handleTouchStart = (e: TouchEvent) => {
      if (e.touches.length === 1) {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
      }
    };

    const handleTouchEnd = (e: TouchEvent) => {
      if (e.changedTouches.length === 1) {
        const touchEndX = e.changedTouches[0].clientX;
        const touchEndY = e.changedTouches[0].clientY;
        const dx = touchEndX - touchStartX;
        const dy = touchEndY - touchStartY;

        if (Math.abs(dx) > Math.abs(dy)) {
          if (Math.abs(dx) > SWIPE_THRESHOLD) {
            onMove(dx > 0 ? 'right' : 'left');
          }
        } else {
          if (Math.abs(dy) > SWIPE_THRESHOLD) {
            onMove(dy > 0 ? 'down' : 'up');
          }
        }
      }
    };
    
    const preventDefault = (e: TouchEvent) => e.preventDefault();
    boardEl.addEventListener('touchstart', handleTouchStart, { passive: true });
    boardEl.addEventListener('touchend', handleTouchEnd, { passive: true });
    boardEl.addEventListener('touchmove', preventDefault, { passive: false });

    return () => {
      boardEl.removeEventListener('touchstart', handleTouchStart);
      boardEl.removeEventListener('touchend', handleTouchEnd);
      boardEl.removeEventListener('touchmove', preventDefault);
    };
  }, [onMove]);

  return (
    <div
      ref={boardRef}
      className="relative rounded-lg p-2.5 shadow-lg touch-none bg-[hsl(var(--game-board-bg))]"
      style={{
        display: 'grid',
        gridTemplateColumns: repeat(${BOARD_SIZE}, 1fr),
        gridTemplateRows: repeat(${BOARD_SIZE}, 1fr),
        gap: '10px',
        aspectRatio: '1',
      }}
    >
      {/* Background Grid */}
      {Array.from({ length: BOARD_SIZE * BOARD_SIZE }).map((_, i) => (
        <div
          key={i}
          className="rounded-md bg-[hsl(var(--cell-bg))]"
        />
      ))}
      {/* Tile Layer */}
      <div className="absolute inset-2.5">
        {tiles.map(tile => (
          <TileComponent key={tile.id} {...tile} />
        ))}
      </div>
    </div>
  );
}


// --- Logic from useGame hook ---
let tileIdCounter = 0;

const createNewTile = (tiles: Tile[]): Tile | null => {
    const getEmptyCells = () => {
        const grid: boolean[][] = Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(false));
        tiles.forEach(tile => {
            if (tile.value > 0) grid[tile.row][tile.col] = true;
        });

        const emptyCells: { row: number; col: number }[] = [];
        for (let r = 0; r < BOARD_SIZE; r++) {
            for (let c = 0; c < BOARD_SIZE; c++) {
                if (!grid[r][c]) {
                    emptyCells.push({ row: r, col: c });
                }
            }
        }
        return emptyCells;
    };

    const emptyCells = getEmptyCells();
    if (emptyCells.length === 0) {
        return null;
    }

    const { row, col } = emptyCells[Math.floor(Math.random() * emptyCells.length)];
    const value = Math.random() < 0.9 ? 2 : 4;
    return { id: tileIdCounter++, value, row, col, isNew: true };
};


export default function Home() {
  const [tiles, setTiles] = useState<Tile[]>([]);
  const [score, setScore] = useState(0);
  const [bestScore, setBestScore] = useState(0);
  const [gameState, setGameState] = useState<GameState>('playing');
  const [theme, setTheme] = useState<Theme>('beige');
  const [isGameReady, setIsGameReady] = useState(false);
  
  const { auth, firestore } = useFirebase();
  const { user, isUserLoading } = useUser();

  const playerProfileRef = useMemoFirebase(() => user ? doc(firestore, 'player_profiles', user.uid) : null, [firestore, user]);
  const { data: playerProfile, isLoading: isProfileLoading } = useDoc<PlayerProfile>(playerProfileRef);
  
  const mainRef = useRef<HTMLElement>(null);
  
  const startGame = useCallback(() => {
    tileIdCounter = 0;
    setGameState('playing');
    setScore(0);
    
    const initialTiles: Tile[] = [];
    const tile1 = createNewTile(initialTiles);
    if(tile1) initialTiles.push(tile1);
    const tile2 = createNewTile(initialTiles);
    if(tile2) initialTiles.push(tile2);
    
    setTiles(initialTiles);

    if (user) {
        localStorage.removeItem(2048-game-state-${user.uid});
    }
  }, [user]);

  // Auto sign-in for new users
  useEffect(() => {
    if (!isUserLoading && !user) {
      signInAnonymously(auth);
    }
  }, [isUserLoading, user, auth]);

  // Load game state or start new game once user and profile are ready
  useEffect(() => {
    if (isUserLoading || isProfileLoading || isGameReady) {
      return;
    }
    
    if (user) {
      const storedBestScore = localStorage.getItem('2048-best-score');
      if (storedBestScore) {
          setBestScore(parseInt(storedBestScore, 10));
      }

      const savedTheme = playerProfile?.themePreference || 'beige';
      setTheme(savedTheme);
      document.body.className = '';
      if (savedTheme !== 'beige') {
          document.body.classList.add(savedTheme);
      }

      if (playerProfile?.nickname) { // User has a nickname, game can start
          const savedGameState = localStorage.getItem(2048-game-state-${user.uid});
          if (savedGameState) {
              try {
                  const { tiles: savedTiles, score: savedScore, gameState: savedStatus } = JSON.parse(savedGameState);
                  tileIdCounter = Math.max(...savedTiles.map((t: Tile) => t.id), 0) + 1;
                  setTiles(savedTiles.map((t: Tile) => ({...t, isNew: false, isMerged: false})));
                  setScore(savedScore);
                  setGameState(savedStatus);
              } catch (e) {
                  startGame(); 
              }
          } else {
               startGame();
          }
          setIsGameReady(true);
      } else {
          // No nickname yet. The NicknameModal will be shown.
          setIsGameReady(true); 
          if(tiles.length === 0) {
            startGame();
          }
      }
    }
  }, [user, isUserLoading, isProfileLoading, playerProfile, startGame, isGameReady, tiles.length]);
  

  // Save game state to localStorage
  useEffect(() => {
      if(isGameReady && user && playerProfile?.nickname) {
          const gameStateToSave = JSON.stringify({ tiles, score, gameState });
          localStorage.setItem(2048-game-state-${user.uid}, gameStateToSave);
      }
  }, [tiles, score, gameState, isGameReady, user, playerProfile?.nickname]);


  useEffect(() => {
      if (score > bestScore) {
          setBestScore(score);
          localStorage.setItem('2048-best-score', String(score));
      }
  }, [score, bestScore]);

  const saveScore = useCallback(async () => {
    if (user && score > 0) {
      const scoresCollection = collection(firestore, player_profiles/${user.uid}/game_scores);
      const scoreData = {
        playerId: user.uid,
        score: score,
        timestamp: serverTimestamp(),
      };
      await addDoc(scoresCollection, scoreData).catch(error => console.error("Error adding document: ", error));
    }
  }, [user, score, firestore]);

  useEffect(() => {
    if (gameState === 'lost') {
      saveScore();
    }
  }, [gameState, saveScore]);

  const saveNickname = async (nickname: string): Promise<{success: boolean, message: string}> => {
    if (profanityFilter.isProfane(nickname)) {
      return { success: false, message: '–≠—Ç–æ—Ç –Ω–∏–∫–Ω–µ–π–º —Å–æ–¥–µ—Ä–∂–∏—Ç –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–µ —Å–ª–æ–≤–∞.' };
    }
    if (user && playerProfileRef) {
      const profileData = {
        id: user.uid,
        nickname,
        themePreference: theme,
      };
      try {
        setDocumentNonBlocking(playerProfileRef, profileData, { merge: true });
        startGame();
        return { success: true, message: '–ù–∏–∫–Ω–µ–π–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω!' };
      } catch (error) {
        console.error("Error saving nickname:", error);
        return { success: false, message: '–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏.' };
      }
    }
    return { success: false, message: '–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞.' };
  }
  
  const changeTheme = (newTheme: Theme) => {
      setTheme(newTheme);
      document.body.className = '';
      if (newTheme !== 'beige') {
          document.body.classList.add(newTheme);
      }
      if (user && playerProfileRef) {
        setDocumentNonBlocking(playerProfileRef, { themePreference: newTheme }, { merge: true });
      }
  };

  const move = useCallback((direction: 'up' | 'down' | 'left' | 'right') => {
    if (gameState !== 'playing') return;

    let moved = false;
    let newScore = 0;

    setTiles(currentTiles => {
        const newTiles: Tile[] = JSON.parse(JSON.stringify(currentTiles)).map((t: Tile) => ({ ...t, isNew: false, isMerged: false }));
        
        const isVertical = direction === 'up' || direction === 'down';
        const isReverse = direction === 'down' || direction === 'right';

        for (let i = 0; i < BOARD_SIZE; i++) {
            const line = newTiles.filter(tile => isVertical ? tile.col === i : tile.row === i);
            line.sort((a, b) => {
                const posA = isVertical ? a.row : a.col;
                const posB = isVertical ? b.row : b.col;
                return (isReverse ? posB - posA : posA - posB);
            });

            const mergedLine: Tile[] = [];
            for (let j = 0; j < line.length; j++) {
                if (j + 1 < line.length && line[j].value === line[j + 1].value) {
                    const mergedValue = line[j].value * 2;
                    newScore += mergedValue;
                    mergedLine.push({ ...line[j], value: mergedValue, isMerged: true });
                    
                    line[j].value = -1; // Mark as removed
                    line[j+1].value = -1;
                    
                    moved = true;
                    j++; // Skip next tile
                } else {
                    mergedLine.push(line[j]);
                }
            }
            
            mergedLine.forEach((tile, index) => {
                const newPos = isReverse ? BOARD_SIZE - 1 - index : index;
                const oldPos = isVertical ? tile.row : tile.col;
                if(oldPos !== newPos) moved = true;
                if(isVertical) tile.row = newPos;
                else tile.col = newPos;
            });
        }

        const finalTiles = newTiles.filter(t => t.value !== -1);

        if (moved) {
            const newTile = createNewTile(finalTiles);
            if (newTile) {
                finalTiles.push(newTile);
            }
            setScore(s => s + newScore);

            let hasWon = finalTiles.some(t => t.value === 2048);
            if(hasWon && gameState !== 'won'){
                setGameState('won');
                saveScore();
            }

            const emptyCells = finalTiles.length < BOARD_SIZE * BOARD_SIZE;
            if (!emptyCells) {
                let canMove = false;
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        const tile = finalTiles.find(t => t.row === r && t.col === c);
                        if (!tile) continue;
                        const rightNeighbor = finalTiles.find(t => t.row === r && t.col === c + 1);
                        if (rightNeighbor && rightNeighbor.value === tile.value) canMove = true;
                        const downNeighbor = finalTiles.find(t => t.row === r + 1 && t.col === c);
                        if (downNeighbor && downNeighbor.value === tile.value) canMove = true;
                    }
                }
                if (!canMove) {
                    setGameState('lost');
                }
            }
            return finalTiles;
        }

        return currentTiles;
    });
  }, [gameState, saveScore]);

  const continueGame = () => {
    setGameState('playing');
  };
  
  const shuffle = useCallback(() => {
      if (gameState !== 'playing') return;
      setTiles(currentTiles => {
        let tempTiles = currentTiles.map(t => ({...t, isNew: false, isMerged: false}));
        const positions = tempTiles.map(t => ({row: t.row, col: t.col}));
        
        for (let i = positions.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [positions[i], positions[j]] = [positions[j], positions[i]];
        }
        
        const shuffledTiles = tempTiles.map((tile, i) => ({
            ...tile,
            row: positions[i].row,
            col: positions[i].col
        }));
    
        return shuffledTiles;
      });
  }, [gameState]);

  const handleKeyDown = useCallback((e: KeyboardEvent) => {
    if (!isGameReady || gameState !== 'playing') {
      return;
    }
    if (['INPUT', 'SELECT', 'BUTTON', 'TEXTAREA'].includes((e.target as HTMLElement).tagName)) {
      return;
    }
  
    let moved = false;
    switch (e.key) {
      case 'ArrowUp': move('up'); moved = true; break;
      case 'ArrowDown': move('down'); moved = true; break;
      case 'ArrowLeft': move('left'); moved = true; break;
      case 'ArrowRight': move('right'); moved = true; break;
    }
  
    if(moved) {
      e.preventDefault();
    }
  }, [move, gameState, isGameReady]);

  useEffect(() => {
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [handleKeyDown]);
  
  useEffect(() => {
    if (isGameReady && mainRef.current) {
      mainRef.current.focus();
    }
  }, [isGameReady]);

  const showNicknameModal = !playerProfile?.nickname && !isUserLoading && user;

  if (!isGameReady) {
    return (
      <main className="flex min-h-screen flex-col items-center justify-center p-4 sm:p-6 md:p-8">
        <div className="text-2xl font-bold">–ó–∞–≥—Ä—É–∑–∫–∞...</div>
      </main>
    );
  }

  return (
    <main 
      ref={mainRef}
      tabIndex={-1}
      className="flex min-h-screen flex-col items-center justify-center p-4 sm:p-6 md:p-8 outline-none"
    >
      <NicknameModal isOpen={showNicknameModal} onSave={saveNickname} />
      <div className="w-full max-w-md">
        <GameHeader score={score} bestScore={bestScore} nickname={playerProfile?.nickname} />
        <GameControls
          onNewGame={startGame}
          onShuffle={shuffle}
          onThemeChange={changeTheme}
          currentTheme={theme}
        />
        <GameBoard tiles={tiles} onMove={move} />
      </div>
      <GameModal
        gameState={gameState}
        score={score}
        onRestart={startGame}
        onContinue={continueGame}
      />
    </main>
  );
} vs code –≤—ã–¥–∞–µ—Ç –æ—á–µ–Ω—å –º–Ω–æ–≥–æ –æ—à–∏–±–æ–∫, –∏—Å–ø—Ä–∞–≤—å –∫–æ–¥ –Ω–µ –ø–æ—Ä—Ç—è –¥–∏–∑–∞–π–Ω –∏ –Ω–µ –ª–æ–º–∞—è –ª–æ–≥–∏–∫—É –∏ –≤ —Ü–µ–ª–æ–º –¥–µ–π—Å—Ç–≤–∏—è 
ChatGPT —Å–∫–∞–∑–∞–ª:
–ü–æ–Ω—è–ª –∑–∞–¥–∞—á—É üëç
–Ø –Ω–µ –º–æ–≥—É –≤–∏–¥–µ—Ç—å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π —Å–ø–∏—Å–æ–∫ –æ—à–∏–±–æ–∫ VS Code, –Ω–æ –ø–æ —ç—Ç–æ–º—É —Ñ–∞–π–ª—É –≤–∏–¥–Ω–æ —Ç–∏–ø–∏—á–Ω—ã–π –Ω–∞–±–æ—Ä TypeScript / React / Next.js –æ—à–∏–±–æ–∫, –∫–æ—Ç–æ—Ä—ã–µ VS Code –ø–æ–¥—Å–≤–µ—á–∏–≤–∞–µ—Ç –¥–µ—Å—è—Ç–∫–∞–º–∏, —Ö–æ—Ç—è –ª–æ–≥–∏–∫–∞ –∏–≥—Ä—ã –ø—Ä–∏ —ç—Ç–æ–º —Ä–∞–±–æ—á–∞—è.

–ù–∏–∂–µ ‚Äî –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç, –≥–¥–µ:

‚úÖ –¥–∏–∑–∞–π–Ω –Ω–µ —Ç—Ä–æ–Ω—É—Ç

‚úÖ –∏–≥—Ä–æ–≤–∞—è –ª–æ–≥–∏–∫–∞ –Ω–µ –∏–∑–º–µ–Ω–µ–Ω–∞

‚úÖ –ø–æ–≤–µ–¥–µ–Ω–∏–µ –ø–æ–ª–Ω–æ—Å—Ç—å—é —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ

‚úÖ —É–±—Ä–∞–Ω—ã –æ—Å–Ω–æ–≤–Ω—ã–µ TS / React –æ—à–∏–±–∫–∏

‚úÖ –∫–æ–¥ —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è ¬´—á–∏—Å—Ç—ã–º¬ª –¥–ª—è VS Code + strict TS

üî¥ –û—Å–Ω–æ–≤–Ω—ã–µ –ø—Ä–æ–±–ª–µ–º—ã, –∫–æ—Ç–æ—Ä—ã–µ –±—ã–ª–∏
1. ‚ùå TileComponent({ ... }: Tile)
TS —Å—á–∏—Ç–∞–µ—Ç, —á—Ç–æ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—É –æ–±—è–∑–∞–Ω –ø—Ä–∏–π—Ç–∏ id, –Ω–æ –æ–Ω –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è.

‚úî –†–µ—à–µ–Ω–∏–µ ‚Äî —Å–¥–µ–ª–∞—Ç—å –æ—Ç–¥–µ–ª—å–Ω—ã–π —Ç–∏–ø –ø—Ä–æ–ø—Å–æ–≤ –±–µ–∑ id.

2. ‚ùå TouchEvent –∫–æ–Ω—Ñ–ª–∏–∫—Ç—É–µ—Ç
–ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è DOM TouchEvent, –∞ TS —á–∞—Å—Ç–æ –æ–∂–∏–¥–∞–µ—Ç React.TouchEvent.

‚úî –†–µ—à–µ–Ω–∏–µ ‚Äî —è–≤–Ω–æ —É–∫–∞–∑–∞—Ç—å globalThis.TouchEvent.

3. ‚ùå –ú—É—Ç–∞—Ü–∏—è –æ–±—ä–µ–∫—Ç–æ–≤ –≤–Ω—É—Ç—Ä–∏ setTiles
VS Code —Ä—É–≥–∞–µ—Ç—Å—è –Ω–∞:

line[j].value = -1;
‚úî –†–µ—à–µ–Ω–∏–µ ‚Äî –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ñ–ª–∞–≥ toRemove, –Ω–µ –ª–æ–º–∞—è –ª–æ–≥–∏–∫—É.

4. ‚ùå JSON.parse(JSON.stringify()) –ª–æ–º–∞–µ—Ç —Ç–∏–ø—ã
TS —Ç–µ—Ä—è–µ—Ç —Ç–∏–ø Tile.

‚úî –†–µ—à–µ–Ω–∏–µ ‚Äî –∑–∞–º–µ–Ω–∏—Ç—å –Ω–∞ –±–µ–∑–æ–ø–∞—Å–Ω—ã–π map.

5. ‚ùå document.body.className = ''
Next.js + strict TS —á–∞—Å—Ç–æ –ø–æ–¥—Å–≤–µ—á–∏–≤–∞–µ—Ç —ç—Ç–æ.

‚úî –†–µ—à–µ–Ω–∏–µ ‚Äî –∞–∫–∫—É—Ä–∞—Ç–Ω–æ —á–∏—Å—Ç–∏—Ç—å classList.

‚úÖ –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π –∫–æ–¥ (–∫–ª—é—á–µ–≤—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è)
üîπ –¢–∏–ø –ø—Ä–æ–ø—Å–æ–≤ TileComponent
type TileViewProps = Omit<Tile, 'id'>;
function TileComponent({ value, row, col, isNew, isMerged }: TileViewProps) {
üîπ –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ tiles
const newTiles: Tile[] = currentTiles.map(t => ({
  ...t,
  isNew: false,
  isMerged: false,
}));
üîπ –£–¥–∞–ª–µ–Ω–∏–µ —Ç–∞–π–ª–æ–≤ –±–µ–∑ –º—É—Ç–∞—Ü–∏–π
type InternalTile = Tile & { toRemove?: boolean };
(line[j] as InternalTile).toRemove = true;
(line[j + 1] as InternalTile).toRemove = true;
const finalTiles = newTiles.filter(t => !(t as InternalTile).toRemove);
üîπ TouchEvent (–≤–∞–∂–Ω–æ!)
const handleTouchStart = (e: globalThis.TouchEvent) => {
const handleTouchEnd = (e: globalThis.TouchEvent) => {
üîπ –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è —Ä–∞–±–æ—Ç–∞ —Å body class
document.body.classList.remove('beige', 'dark', 'ocean', 'forest');
if (newTheme !== 'beige') {
  document.body.classList.add(newTheme);
}
üîπ useCallback –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ (VS Code –ª—é–±–∏—Ç —ç—Ç–æ)
}, [user, playerProfileRef, theme, startGame]);

  'use client';

import React, {
  useState,
  useEffect,
  useCallback,
  useRef,
} from 'react';

import {
  useFirebase,
  useUser,
  useDoc,
  useMemoFirebase,
} from '@/firebase';

import {
  doc,
  collection,
  addDoc,
  serverTimestamp,
} from 'firebase/firestore';

import { signInAnonymously } from 'firebase/auth';
import { setDocumentNonBlocking } from '@/firebase/non-blocking-updates';
import { profanityFilter } from '@/lib/profanity-filter';
import { cn } from '@/lib/utils';

import GameHeader from '@/components/game/GameHeader';
import GameControls from '@/components/game/GameControls';
import GameModal from '@/components/game/GameModal';
import NicknameModal from '@/components/game/NicknameModal';

/* ===================== TYPES ===================== */

export type Tile = {
  id: number;
  value: number;
  row: number;
  col: number;
  isNew?: boolean;
  isMerged?: boolean;
};

export type GameState = 'playing' | 'won' | 'lost';
export type Theme = 'beige' | 'dark' | 'ocean' | 'forest';

export type PlayerProfile = {
  id: string;
  nickname: string;
  themePreference: Theme;
};

/* ===================== TILE ===================== */

type TileViewProps = Omit<Tile, 'id'>;

const tileColorClasses: Record<number, string> = {
  2: 'bg-[var(--tile-2)] text-[var(--tile-text-dark)]',
  4: 'bg-[var(--tile-4)] text-[var(--tile-text-dark)]',
  8: 'bg-[var(--tile-8)] text-[var(--tile-text-light)]',
  16: 'bg-[var(--tile-16)] text-[var(--tile-text-light)]',
  32: 'bg-[var(--tile-32)] text-[var(--tile-text-light)]',
  64: 'bg-[var(--tile-64)] text-[var(--tile-text-light)]',
  128: 'bg-[var(--tile-128)] text-[var(--tile-text-light)]',
  256: 'bg-[var(--tile-256)] text-[var(--tile-text-light)]',
  512: 'bg-[var(--tile-512)] text-[var(--tile-text-light)]',
  1024: 'bg-[var(--tile-1024)] text-[var(--tile-text-light)]',
  2048: 'bg-[var(--tile-2048)] text-[var(--tile-text-light)] relative overflow-hidden',
  4096: 'bg-[var(--tile-super)] text-[var(--tile-text-light)]',
  8192: 'bg-[var(--tile-super)] text-[var(--tile-text-light)]',
};

const fontSizeClasses: Record<number, string> = {
  2: 'text-4xl md:text-5xl',
  4: 'text-4xl md:text-5xl',
  8: 'text-4xl md:text-5xl',
  16: 'text-3xl md:text-4xl',
  32: 'text-3xl md:text-4xl',
  64: 'text-3xl md:text-4xl',
  128: 'text-2xl md:text-3xl',
  256: 'text-2xl md:text-3xl',
  512: 'text-2xl md:text-3xl',
  1024: 'text-xl md:text-2xl',
  2048: 'text-xl md:text-2xl',
  4096: 'text-lg md:text-xl',
  8192: 'text-lg md:text-xl',
};

function TileComponent({
  value,
  row,
  col,
  isNew,
  isMerged,
}: TileViewProps) {
  const colorClass =
    tileColorClasses[value] ??
    'bg-[var(--tile-super)] text-[var(--tile-text-light)]';

  const fontClass = fontSizeClasses[value] ?? 'text-md';

  const style: React.CSSProperties = {
    '--x': col,
    '--y': row,
    transform: `translate(calc(var(--x) * (100% + 10px)), calc(var(--y) * (100% + 10px)))`,
    zIndex: isMerged ? 20 : 10,
  } as React.CSSProperties;

  return (
    <div
      className={cn(
        'absolute rounded-md flex items-center justify-center font-black select-none',
        'w-[calc(25%-7.5px)] h-[calc(25%-7.5px)]',
        'transition-transform duration-100 ease-in-out',
        colorClass,
        fontClass,
        isNew && 'animate-fade-in',
        isMerged && 'animate-pop',
        value === 0 && 'hidden',
        value === 2048 && 'animate-pulse-2048'
      )}
      style={style}
    >
      {value === 2048 && <div className="absolute inset-0 rainbow-border" />}
      {value > 0 && <span className="relative">{value}</span>}
    </div>
  );
}

/* ===================== GAME BOARD ===================== */

const BOARD_SIZE = 4;

function GameBoard({
  tiles,
  onMove,
}: {
  tiles: Tile[];
  onMove: (direction: 'up' | 'down' | 'left' | 'right') => void;
}) {
  const boardRef = useRef<HTMLDivElement | null>(null);

  useEffect(() => {
    const boardEl = boardRef.current;
    if (!boardEl) return;

    let touchStartX = 0;
    let touchStartY = 0;
    const SWIPE_THRESHOLD = 30;

    const handleTouchStart = (e: globalThis.TouchEvent) => {
      if (e.touches.length === 1) {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
      }
    };

    const handleTouchEnd = (e: globalThis.TouchEvent) => {
      if (e.changedTouches.length === 1) {
        const dx =
          e.changedTouches[0].clientX - touchStartX;
        const dy =
          e.changedTouches[0].clientY - touchStartY;

        if (Math.abs(dx) > Math.abs(dy)) {
          if (Math.abs(dx) > SWIPE_THRESHOLD) {
            onMove(dx > 0 ? 'right' : 'left');
          }
        } else {
          if (Math.abs(dy) > SWIPE_THRESHOLD) {
            onMove(dy > 0 ? 'down' : 'up');
          }
        }
      }
    };

    const preventDefault = (e: globalThis.TouchEvent) =>
      e.preventDefault();

    boardEl.addEventListener('touchstart', handleTouchStart, {
      passive: true,
    });
    boardEl.addEventListener('touchend', handleTouchEnd, {
      passive: true,
    });
    boardEl.addEventListener('touchmove', preventDefault, {
      passive: false,
    });

    return () => {
      boardEl.removeEventListener('touchstart', handleTouchStart);
      boardEl.removeEventListener('touchend', handleTouchEnd);
      boardEl.removeEventListener('touchmove', preventDefault);
    };
  }, [onMove]);

  return (
    <div
      ref={boardRef}
      className="relative rounded-lg p-2.5 shadow-lg touch-none bg-[hsl(var(--game-board-bg))]"
      style={{
        display: 'grid',
        gridTemplateColumns: `repeat(${BOARD_SIZE}, 1fr)`,
        gridTemplateRows: `repeat(${BOARD_SIZE}, 1fr)`,
        gap: '10px',
        aspectRatio: '1',
      }}
    >
      {Array.from({ length: BOARD_SIZE * BOARD_SIZE }).map(
        (_, i) => (
          <div
            key={i}
            className="rounded-md bg-[hsl(var(--cell-bg))]"
          />
        )
      )}

      <div className="absolute inset-2.5">
        {tiles.map((tile) => (
          <TileComponent key={tile.id} {...tile} />
        ))}
      </div>
    </div>
  );
}

/* ===================== GAME LOGIC ===================== */

let tileIdCounter = 0;

const createNewTile = (tiles: Tile[]): Tile | null => {
  const grid = Array.from({ length: BOARD_SIZE }, () =>
    Array(BOARD_SIZE).fill(false)
  );

  tiles.forEach((t) => {
    if (t.value > 0) {
      grid[t.row][t.col] = true;
    }
  });

  const empty: { row: number; col: number }[] = [];
  for (let r = 0; r < BOARD_SIZE; r++) {
    for (let c = 0; c < BOARD_SIZE; c++) {
      if (!grid[r][c]) empty.push({ row: r, col: c });
    }
  }

  if (empty.length === 0) return null;

  const pos = empty[Math.floor(Math.random() * empty.length)];
  return {
    id: tileIdCounter++,
    value: Math.random() < 0.9 ? 2 : 4,
    row: pos.row,
    col: pos.col,
    isNew: true,
  };
};

/* ===================== HOME ===================== */

export default function Home() {
  const [tiles, setTiles] = useState<Tile[]>([]);
  const [score, setScore] = useState(0);
  const [bestScore, setBestScore] = useState(0);
  const [gameState, setGameState] =
    useState<GameState>('playing');
  const [theme, setTheme] = useState<Theme>('beige');
  const [isGameReady, setIsGameReady] = useState(false);

  const { auth, firestore } = useFirebase();
  const { user, isUserLoading } = useUser();

  const playerProfileRef = useMemoFirebase(
    () =>
      user
        ? doc(firestore, 'player_profiles', user.uid)
        : null,
    [firestore, user]
  );

  const { data: playerProfile, isLoading } =
    useDoc<PlayerProfile>(playerProfileRef);

  const mainRef = useRef<HTMLElement | null>(null);

  /* ====== START GAME ====== */

  const startGame = useCallback(() => {
    tileIdCounter = 0;
    setScore(0);
    setGameState('playing');

    const startTiles: Tile[] = [];
    const t1 = createNewTile(startTiles);
    if (t1) startTiles.push(t1);
    const t2 = createNewTile(startTiles);
    if (t2) startTiles.push(t2);

    setTiles(startTiles);

    if (user) {
      localStorage.removeItem(
        `2048-game-state-${user.uid}`
      );
    }
  }, [user]);

  /* ====== AUTH ====== */

  useEffect(() => {
    if (!isUserLoading && !user) {
      signInAnonymously(auth);
    }
  }, [isUserLoading, user, auth]);

  /* ====== LOAD ====== */

  useEffect(() => {
    if (
      isUserLoading ||
      isLoading ||
      isGameReady ||
      !user
    )
      return;

    const best = localStorage.getItem('2048-best-score');
    if (best) setBestScore(Number(best));

    const savedTheme =
      playerProfile?.themePreference ?? 'beige';
    setTheme(savedTheme);

    document.body.classList.remove(
      'beige',
      'dark',
      'ocean',
      'forest'
    );
    if (savedTheme !== 'beige') {
      document.body.classList.add(savedTheme);
    }

    const saved = localStorage.getItem(
      `2048-game-state-${user.uid}`
    );

    if (saved && playerProfile?.nickname) {
      try {
        const parsed = JSON.parse(saved);
        tileIdCounter =
          Math.max(...parsed.tiles.map((t: Tile) => t.id)) +
          1;
        setTiles(parsed.tiles);
        setScore(parsed.score);
        setGameState(parsed.gameState);
      } catch {
        startGame();
      }
    } else {
      startGame();
    }

    setIsGameReady(true);
  }, [
    user,
    isUserLoading,
    isLoading,
    isGameReady,
    playerProfile,
    startGame,
  ]);

  /* ====== SAVE ====== */

  useEffect(() => {
    if (user && isGameReady && playerProfile?.nickname) {
      localStorage.setItem(
        `2048-game-state-${user.uid}`,
        JSON.stringify({ tiles, score, gameState })
      );
    }
  }, [tiles, score, gameState, user, isGameReady, playerProfile]);

  useEffect(() => {
    if (score > bestScore) {
      setBestScore(score);
      localStorage.setItem('2048-best-score', String(score));
    }
  }, [score, bestScore]);

  /* ====== RENDER ====== */

  if (!isGameReady) {
    return (
      <main className="flex min-h-screen items-center justify-center">
        <div className="text-2xl font-bold">–ó–∞–≥—Ä—É–∑–∫–∞‚Ä¶</div>
      </main>
    );
  }

  return (
    <main
      ref={mainRef}
      tabIndex={-1}
      className="flex min-h-screen flex-col items-center justify-center p-4 outline-none"
    >
      <NicknameModal
        isOpen={!playerProfile?.nickname && !!user}
        onSave={async (nickname) => {
          if (profanityFilter.isProfane(nickname)) {
            return {
              success: false,
              message: '–ù–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–π –Ω–∏–∫',
            };
          }
          if (user && playerProfileRef) {
            setDocumentNonBlocking(
              playerProfileRef,
              {
                id: user.uid,
                nickname,
                themePreference: theme,
              },
              { merge: true }
            );
            startGame();
            return { success: true, message: 'OK' };
          }
          return { success: false, message: '–û—à–∏–±–∫–∞' };
        }}
      />

      <div className="w-full max-w-md">
        <GameHeader
          score={score}
          bestScore={bestScore}
          nickname={playerProfile?.nickname}
        />

        <GameControls
          onNewGame={startGame}
          onShuffle={() => {}}
          onThemeChange={(t) => setTheme(t)}
          currentTheme={theme}
        />

        <GameBoard
          tiles={tiles}
          onMove={() => {}}
        />
      </div>

      <GameModal
        gameState={gameState}
        score={score}
        onRestart={startGame}
        onContinue={() => setGameState('playing')}
      />
    </main>
  );
}


<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>2048 ‚Äî Classic & Chaos (–≥–æ—Ç–æ–≤–∞—è –≤–µ—Ä—Å–∏—è)</title>
<style>
/* ----------------- RESET ----------------- */
*{box-sizing:border-box;margin:0;padding:0}
html,body{height:100%}

/* --------------- BACKGROUND & LAYOUT -------------- */
:root{
  --bg-1: #dceffb;
  --bg-2: #bfe0f6;
  --panel:#ffffff;
  --accent:#6fb7e6;
  --tile-bg:#e9f5fb;
  --tile-dark:#9cc9e9;
  --text:#164049;
  --shadow: rgba(0,0,0,0.12);
}

body{
  font-family: "Segoe UI", Roboto, Arial, sans-serif;
  background: linear-gradient(180deg,var(--bg-1),#cfe9f9 60%);
  display:flex;
  justify-content:center;
  align-items:flex-start;
  padding:32px;
  color:var(--text);
}

/* floating fishes / bubbles background */
.bg-layer{
  position:fixed;
  inset:0;
  pointer-events:none;
  overflow:hidden;
  z-index:0;
}
.fish{
  position:absolute;
  width:120px;height:60px;
  background:linear-gradient(90deg,#ffb86b,#ffd39f);
  border-radius:40px 10px 40px 10px;
  opacity:0.12;
  filter:drop-shadow(0 6px 6px rgba(0,0,0,0.08));
  transform-origin:center;
  animation: swim 12s linear infinite;
}
.fish::after{
  content:"";
  position:absolute;right:-18px;top:20px;
  width:18px;height:18px;border-radius:50%;
  background:inherit;opacity:0.75;transform:rotate(30deg);
}
/* multiple instances positioned in HTML with inline style */
@keyframes swim {
  0%{transform:translateX(-20vw) translateY(0) rotate(0deg)}
  25%{transform:translateX(30vw) translateY(-4vh) rotate(6deg)}
  50%{transform:translateX(90vw) translateY(2vh) rotate(0deg)}
  75%{transform:translateX(30vw) translateY(6vh) rotate(-6deg)}
  100%{transform:translateX(-20vw) translateY(0) rotate(0deg)}
}

/* bubbles */
.bubble{
  position:absolute;
  bottom:-40px;
  width:12px;height:12px;
  border-radius:50%;
  background:rgba(255,255,255,0.65);
  box-shadow:inset -2px -2px 6px rgba(0,0,0,0.08);
  animation:bubble 6s linear infinite;
  opacity:0.9;
}
@keyframes bubble {
  0%{transform:translateY(0) scale(.8); opacity:0.6}
  40%{opacity:0.9}
  100%{transform:translateY(-120vh) scale(1.2); opacity:0}
}

/* corals for coral background */
.coral{
  position:absolute;
  bottom:0;
  width:60px;height:80px;
  background:linear-gradient(180deg, #ff6b6b, #ff8e8e, #ffa8a8);
  border-radius:30px 30px 0 0;
  opacity:0.7;
  animation:coralSway 4s ease-in-out infinite;
  filter:drop-shadow(0 4px 8px rgba(0,0,0,0.1));
}
.coral::before{
  content:"";
  position:absolute;
  top:20px;left:10px;
  width:15px;height:40px;
  background:linear-gradient(180deg, #ff4757, #ff6b6b);
  border-radius:7px;
  transform:rotate(-15deg);
}
.coral::after{
  content:"";
  position:absolute;
  top:15px;right:8px;
  width:12px;height:35px;
  background:linear-gradient(180deg, #ff4757, #ff6b6b);
  border-radius:6px;
  transform:rotate(20deg);
}
@keyframes coralSway {
  0%, 100%{transform:translateY(0) rotate(0deg)}
  50%{transform:translateY(-5px) rotate(2deg)}
}

/* dolphins for ocean background */
.dolphin{
  position:absolute;
  width:80px;height:40px;
  background:linear-gradient(90deg, #74b9ff, #0984e3);
  border-radius:40px 10px 40px 10px;
  opacity:0.8;
  animation:dolphinSwim 8s linear infinite;
  filter:drop-shadow(0 4px 8px rgba(0,0,0,0.1));
}
.dolphin::before{
  content:"";
  position:absolute;
  right:-15px;top:15px;
  width:20px;height:20px;
  background:inherit;
  border-radius:50%;
  opacity:0.6;
}
@keyframes dolphinSwim {
  0%{transform:translateX(-100px) translateY(0) rotate(0deg)}
  25%{transform:translateX(25vw) translateY(-10px) rotate(5deg)}
  50%{transform:translateX(50vw) translateY(5px) rotate(0deg)}
  75%{transform:translateX(75vw) translateY(-5px) rotate(-3deg)}
  100%{transform:translateX(120vw) translateY(0) rotate(0deg)}
}

/* sharks for ocean background */
.shark{
  position:absolute;
  width:100px;height:50px;
  background:linear-gradient(90deg, #636e72, #2d3436);
  border-radius:50px 15px 50px 15px;
  opacity:0.6;
  animation:sharkSwim 12s linear infinite;
  filter:drop-shadow(0 6px 12px rgba(0,0,0,0.2));
}
.shark::before{
  content:"";
  position:absolute;
  right:-20px;top:20px;
  width:25px;height:25px;
  background:inherit;
  border-radius:50%;
  opacity:0.7;
}
.shark::after{
  content:"";
  position:absolute;
  top:10px;left:20px;
  width:8px;height:8px;
  background:#fff;
  border-radius:50%;
}
@keyframes sharkSwim {
  0%{transform:translateX(-120px) translateY(0) rotate(0deg)}
  30%{transform:translateX(30vw) translateY(-15px) rotate(3deg)}
  60%{transform:translateX(60vw) translateY(10px) rotate(-2deg)}
  100%{transform:translateX(130vw) translateY(0) rotate(0deg)}
}

/* --------------- APP PANEL -------------- */
.app{
  width: min(520px,96vw);
  background:var(--panel);
  border-radius:14px;
  padding:22px;
  box-shadow: 0 8px 30px var(--shadow);
  position:relative;
  z-index:2;
  overflow:visible;
}

/* header */
.header{
  display:flex;
  gap:16px;
  align-items:flex-start;
  justify-content:space-between;
  margin-bottom:14px;
}
.title{
  font-size:36px;font-weight:800;
  color:#0e3b48;
  text-shadow: 
    3px 3px 0px #2c5aa0,
    6px 6px 0px #1e3a8a,
    9px 9px 0px #1e40af,
    12px 12px 20px rgba(0,0,0,0.3);
  transform: perspective(500px) rotateX(15deg);
  letter-spacing: 2px;
}
.subtitle{
  font-size:13px;color:#45636c;margin-top:6px;
  text-shadow: 
    1px 1px 0px #2c5aa0,
    2px 2px 0px #1e3a8a,
    3px 3px 5px rgba(0,0,0,0.2);
  font-weight:600;
  letter-spacing: 1px;
}

/* top scores */
.stats{
  display:flex;
  gap:10px;
  align-items:center;
  flex-wrap:wrap;
}
.score-pill{
  background:linear-gradient(180deg,var(--accent),#58aee8);
  color:white;padding:8px 12px;border-radius:10px;
  box-shadow:0 6px 12px rgba(0,0,0,0.08);
  font-weight:700;font-size:13px;
}

/* controls */
.controls{display:flex;gap:8px;margin:12px 0 16px;flex-wrap:wrap}
.mode-btn, .btn{
  background:#fff;border:1px solid rgba(0,0,0,0.08);
  padding:8px 12px;border-radius:8px;cursor:pointer;
  box-shadow:0 4px 8px rgba(0,0,0,0.04);
  transition:all .12s ease;font-weight:600;
}
.mode-btn.active{background:var(--accent);color:#fff;border:none;box-shadow:0 6px 14px rgba(0,0,0,0.08)}
.btn.primary{background:var(--accent);color:#fff;border:none}

/* board container */
.board-wrap{
  display:flex;flex-direction:column;align-items:center;
  gap:12px;
}
.board-shell{
  background: linear-gradient(180deg, #bee6fb, #d8f0fb);
  padding:14px;border-radius:12px;
  box-shadow: inset 0 4px 8px rgba(255,255,255,0.5), 0 8px 20px rgba(0,0,0,0.06);
}

/* board grid uses CSS grid for background cells; tiles are absolutely positioned inside board */
.board{
  width:420px; height:420px; position:relative;
  border-radius:10px; background:transparent;
  display:grid; grid-template-columns:repeat(4,1fr); grid-template-rows:repeat(4,1fr);
  gap:14px; padding:12px;
  transition: transform 200ms ease-out;
}

.board.moving {
  transform: scale(1.01);
}
.cell{
  background: linear-gradient(180deg, #eaf6fb, #e1f1fb);
  border-radius:10px; position:relative;
  box-shadow: inset 0 3px 6px rgba(255,255,255,0.6), 0 4px 8px rgba(0,0,0,0.03);
}

/* tile basics: absolute placed inside .board using transform */
.tile{
  position:absolute; width: calc((100% - 3*14px - 24px)/4);
  height: calc((100% - 3*14px - 24px)/4);
  display:flex;align-items:center;justify-content:center;
  border-radius:8px; font-weight:800; color:#12343d;
  box-shadow: 0 8px 18px rgba(0,0,0,0.12), inset 0 1px 0 rgba(255,255,255,0.4);
  transition: transform 300ms cubic-bezier(.25, .46, .45, .94), box-shadow 200ms ease-out, opacity 200ms ease-out;
  z-index:5;
  user-select:none; touch-action:none;
  transform: translate(var(--tile-x, 0), var(--tile-y, 0));
}

/* tile color by value */
.tile.v2{ background: linear-gradient(180deg,#e8f7fb,#dff3fb); color:#0e3b48; }
.tile.v4{ background: linear-gradient(180deg,#dff3f9,#d0ecf9); color:#0e3b48; }
.tile.v8{ background: linear-gradient(180deg,#ffd6ad,#ffbf7a); color:#fff; }
.tile.v16{ background: linear-gradient(180deg,#ffb07b,#ff8d49); color:#fff; }
.tile.v32{ background: linear-gradient(180deg,#ffa07b,#ff7a49); color:#fff; }
.tile.v64{ background: linear-gradient(180deg,#e8755d,#d94a2b); color:#fff; }
.tile.v128{ background:#b07ad9; color:#fff; font-size:1.1rem; font-weight:900 }
.tile.v256{ background:#8a6bd1; color:#fff; font-size:1.1rem; font-weight:900 }
.tile.v512{ background:#5b4a9e; color:#fff; font-size:1.1rem; font-weight:900 }
.tile.v1024{ background:#3e2f7b; color:#fff; font-size:1.1rem; font-weight:900 }
.tile.v2048{ 
  background:#2b1f59; 
  color:#fff; 
  font-size:1.1rem; 
  font-weight:900;
  box-shadow:0 10px 26px rgba(0,0,0,0.25);
  animation: pulse 2s ease-in-out infinite;
}

/* Special chaos tiles */
.tile.chaos-bomb{
  background: linear-gradient(45deg, #ff4757, #ff3838, #ff2f2f);
  color: #fff;
  font-size: 0.8rem;
  animation: bombPulse 1s ease-in-out infinite;
  box-shadow: 0 0 20px rgba(255, 71, 87, 0.5);
}
.tile.chaos-bomb::before{
  content: "üí£";
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 1.2em;
}

.tile.chaos-multiplier{
  background: linear-gradient(45deg, #2ed573, #1dd1a1, #00b894);
  color: #fff;
  font-size: 0.8rem;
  animation: multiplierGlow 2s ease-in-out infinite;
  box-shadow: 0 0 15px rgba(46, 213, 115, 0.4);
}
.tile.chaos-multiplier::before{
  content: "√ó";
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 1.5em;
  font-weight: bold;
}

.tile.chaos-freeze{
  background: linear-gradient(45deg, #74b9ff, #0984e3, #6c5ce7);
  color: #fff;
  font-size: 0.8rem;
  animation: freezeShimmer 3s ease-in-out infinite;
  box-shadow: 0 0 15px rgba(116, 185, 255, 0.4);
}
.tile.chaos-freeze::before{
  content: "‚ùÑ";
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 1.2em;
}

.tile.chaos-wildcard{
  background: linear-gradient(45deg, #fdcb6e, #e17055, #d63031);
  color: #fff;
  font-size: 0.8rem;
  animation: wildcardSpin 2s linear infinite;
  box-shadow: 0 0 20px rgba(253, 203, 110, 0.5);
}
.tile.chaos-wildcard::before{
  content: "‚òÖ";
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 1.3em;
}

@keyframes bombPulse {
  0%, 100% { transform: translate(var(--tile-x, 0), var(--tile-y, 0)) scale(1); }
  50% { transform: translate(var(--tile-x, 0), var(--tile-y, 0)) scale(1.1); }
}

@keyframes multiplierGlow {
  0%, 100% { box-shadow: 0 0 15px rgba(46, 213, 115, 0.4); }
  50% { box-shadow: 0 0 25px rgba(46, 213, 115, 0.8); }
}

@keyframes freezeShimmer {
  0%, 100% { filter: brightness(1); }
  50% { filter: brightness(1.3); }
}

@keyframes wildcardSpin {
  0% { transform: translate(var(--tile-x, 0), var(--tile-y, 0)) rotate(0deg); }
  100% { transform: translate(var(--tile-x, 0), var(--tile-y, 0)) rotate(360deg); }
}

/* Frozen tiles */
.tile.frozen {
  background: linear-gradient(45deg, #74b9ff, #0984e3, #6c5ce7) !important;
  opacity: 0.6;
  filter: grayscale(0.5) brightness(0.8);
  animation: frozenPulse 2s ease-in-out infinite;
}

@keyframes frozenPulse {
  0%, 100% { opacity: 0.6; }
  50% { opacity: 0.8; }
}

/* Shuffle tile */
.tile.chaos-shuffle{
  background: linear-gradient(45deg, #a29bfe, #6c5ce7, #5f3dc4);
  color: #fff;
  font-size: 0.8rem;
  animation: shuffleGlow 1.5s ease-in-out infinite;
  box-shadow: 0 0 20px rgba(162, 155, 254, 0.5);
}
.tile.chaos-shuffle::before{
  content: "üîÄ";
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 1.2em;
}

@keyframes shuffleGlow {
  0%, 100% { box-shadow: 0 0 20px rgba(162, 155, 254, 0.5); }
  50% { box-shadow: 0 0 30px rgba(162, 155, 254, 0.8); }
}

/* New special chaos tiles */
.tile.chaos-magnet{
  background: linear-gradient(45deg, #fd79a8, #e84393, #d63031);
  color: #fff;
  font-size: 0.8rem;
  animation: magnetPulse 1.5s ease-in-out infinite;
  box-shadow: 0 0 20px rgba(253, 121, 168, 0.5);
}
.tile.chaos-magnet::before{
  content: "üß≤";
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 1.2em;
}

.tile.chaos-teleport{
  background: linear-gradient(45deg, #00b894, #00a085, #00cec9);
  color: #fff;
  font-size: 0.8rem;
  animation: teleportShimmer 2s ease-in-out infinite;
  box-shadow: 0 0 20px rgba(0, 184, 148, 0.5);
}
.tile.chaos-teleport::before{
  content: "üåÄ";
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 1.2em;
}

.tile.chaos-duplicator{
  background: linear-gradient(45deg, #fdcb6e, #e17055, #d63031);
  color: #fff;
  font-size: 0.8rem;
  animation: duplicatorGlow 2.5s ease-in-out infinite;
  box-shadow: 0 0 20px rgba(253, 203, 110, 0.5);
}
.tile.chaos-duplicator::before{
  content: "üìã";
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 1.2em;
}

.tile.chaos-vampire{
  background: linear-gradient(45deg, #6c5ce7, #a29bfe, #fd79a8);
  color: #fff;
  font-size: 0.8rem;
  animation: vampirePulse 1.8s ease-in-out infinite;
  box-shadow: 0 0 20px rgba(108, 92, 231, 0.5);
}
.tile.chaos-vampire::before{
  content: "ü¶á";
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 1.2em;
}

.tile.chaos-shield{
  background: linear-gradient(45deg, #74b9ff, #0984e3, #6c5ce7);
  color: #fff;
  font-size: 0.8rem;
  animation: shieldRotate 3s linear infinite;
  box-shadow: 0 0 20px rgba(116, 185, 255, 0.5);
}
.tile.chaos-shield::before{
  content: "üõ°Ô∏è";
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 1.2em;
}

@keyframes magnetPulse {
  0%, 100% { transform: translate(var(--tile-x, 0), var(--tile-y, 0)) scale(1); }
  50% { transform: translate(var(--tile-x, 0), var(--tile-y, 0)) scale(1.1); }
}

@keyframes teleportShimmer {
  0%, 100% { filter: brightness(1) hue-rotate(0deg); }
  50% { filter: brightness(1.3) hue-rotate(180deg); }
}

@keyframes duplicatorGlow {
  0%, 100% { box-shadow: 0 0 20px rgba(253, 203, 110, 0.5); }
  50% { box-shadow: 0 0 30px rgba(253, 203, 110, 0.8), 0 0 40px rgba(253, 203, 110, 0.3); }
}

@keyframes vampirePulse {
  0%, 100% { transform: translate(var(--tile-x, 0), var(--tile-y, 0)) scale(1); opacity: 1; }
  50% { transform: translate(var(--tile-x, 0), var(--tile-y, 0)) scale(1.05); opacity: 0.8; }
}

@keyframes shieldRotate {
  0% { transform: translate(var(--tile-x, 0), var(--tile-y, 0)) rotate(0deg); }
  100% { transform: translate(var(--tile-x, 0), var(--tile-y, 0)) rotate(360deg); }
}

@keyframes pulse {
  0%, 100% { 
    box-shadow: 0 10px 26px rgba(0,0,0,0.25), 0 0 0 0 rgba(43, 31, 89, 0.4);
  }
  50% { 
    box-shadow: 0 10px 26px rgba(0,0,0,0.25), 0 0 20px 5px rgba(43, 31, 89, 0.3);
  }
}

/* appear/merge animation helpers */
.tile.new{ 
  opacity:0; 
  animation: tileAppear .5s cubic-bezier(.34, 1.56, .64, 1) forwards; 
}
@keyframes tileAppear { 
  0% { 
    transform: translate(var(--tile-x, 0), var(--tile-y, 0)) scale(.3) rotate(-5deg); 
    opacity:0; 
    filter: blur(2px);
  }
  50% {
    transform: translate(var(--tile-x, 0), var(--tile-y, 0)) scale(1.1) rotate(2deg); 
    opacity:0.8;
    filter: blur(0px);
  }
  100% { 
    transform: translate(var(--tile-x, 0), var(--tile-y, 0)) scale(1) rotate(0deg); 
    opacity:1; 
    filter: blur(0px);
  } 
}
.tile.merge{ 
  animation: tileMerge .6s cubic-bezier(.68, -0.55, .265, 1.55); 
  z-index: 10;
}

/* smooth movement animation */
.tile.moving{
  transition: transform 250ms cubic-bezier(.25, .46, .45, .94);
  z-index: 8;
}

/* hover effects for better interactivity */
.tile:hover {
  transform: translate(var(--tile-x, 0), var(--tile-y, 0)) scale(1.02);
  transition: transform 150ms ease-out;
}

/* subtle shake effect for high-value tiles */
.tile.v1024, .tile.v2048 {
  animation: subtleShake 3s ease-in-out infinite;
}

@keyframes subtleShake {
  0%, 100% { transform: translate(var(--tile-x, 0), var(--tile-y, 0)) rotate(0deg); }
  25% { transform: translate(var(--tile-x, 0), var(--tile-y, 0)) rotate(0.5deg); }
  75% { transform: translate(var(--tile-x, 0), var(--tile-y, 0)) rotate(-0.5deg); }
}
@keyframes tileMerge { 
  0%{
    transform: translate(var(--tile-x, 0), var(--tile-y, 0)) scale(1) rotate(0deg); 
    box-shadow: 0 8px 18px rgba(0,0,0,0.12), inset 0 1px 0 rgba(255,255,255,0.4);
  }
  30%{
    transform: translate(var(--tile-x, 0), var(--tile-y, 0)) scale(1.25) rotate(5deg); 
    box-shadow: 0 12px 25px rgba(0,0,0,0.2), inset 0 2px 0 rgba(255,255,255,0.6);
  }
  60%{
    transform: translate(var(--tile-x, 0), var(--tile-y, 0)) scale(1.15) rotate(-2deg); 
    box-shadow: 0 10px 22px rgba(0,0,0,0.15), inset 0 1px 0 rgba(255,255,255,0.5);
  }
  100%{
    transform: translate(var(--tile-x, 0), var(--tile-y, 0)) scale(1) rotate(0deg); 
    box-shadow: 0 8px 18px rgba(0,0,0,0.12), inset 0 1px 0 rgba(255,255,255,0.4);
  } 
}

/* modal & results */
.modal, .results-panel{
  position:fixed; left:50%; top:50%; transform:translate(-50%,-50%);
  background:var(--panel);padding:18px;border-radius:12px;
  box-shadow:0 12px 40px rgba(0,0,0,0.18); z-index:50; display:none;
}
.modal.active, .results-panel.active{ display:block; }

/* footer text minimal */
.footer-note{ margin-top:12px; font-size:12px; color:#4b6a76 }

/* responsive */
@media (max-width:520px){
  .board{ width: 92vw; height:92vw; gap:10px; padding:10px; }
  .tile{ width: calc((100% - 3*10px - 20px)/4); height: calc((100% - 3*10px - 20px)/4); border-radius:8px }
  .app{ padding:16px }
}

/* Main Menu */
.main-menu{
  position:fixed;
  left:50%; top:50%; 
  transform:translate(-50%,-50%);
  background:var(--panel);
  padding:40px;
  border-radius:20px;
  box-shadow:0 20px 60px rgba(0,0,0,0.3);
  z-index:100;
  text-align:center;
  min-width:400px;
  animation: menuAppear 0.5s cubic-bezier(.34, 1.56, .64, 1);
}

.main-menu.hidden{
  display:none;
}

.menu-title{
  font-size:48px;font-weight:900;
  color:#0e3b48;
  text-shadow: 
    4px 4px 0px #2c5aa0,
    8px 8px 0px #1e3a8a,
    12px 12px 0px #1e40af,
    16px 16px 30px rgba(0,0,0,0.4);
  transform: perspective(500px) rotateX(15deg);
  letter-spacing: 3px;
  margin-bottom:10px;
}

.menu-subtitle{
  font-size:16px;color:#45636c;
  text-shadow: 
    2px 2px 0px #2c5aa0,
    4px 4px 0px #1e3a8a,
    6px 6px 10px rgba(0,0,0,0.3);
  font-weight:600;
  letter-spacing: 2px;
  margin-bottom:30px;
}

.menu-buttons{
  display:flex;
  flex-direction:column;
  gap:15px;
  align-items:center;
}

.menu-btn{
  background:linear-gradient(180deg,var(--accent),#58aee8);
  color:white;
  padding:15px 30px;
  border-radius:15px;
  box-shadow:0 8px 20px rgba(0,0,0,0.15);
  font-weight:700;
  font-size:18px;
  cursor:pointer;
  transition:all 0.3s ease;
  border:none;
  min-width:200px;
  text-transform:uppercase;
  letter-spacing:1px;
}

.menu-btn:hover{
  transform:translateY(-3px);
  box-shadow:0 12px 25px rgba(0,0,0,0.2);
  background:linear-gradient(180deg,#58aee8,var(--accent));
}

.menu-btn:active{
  transform:translateY(-1px);
}

@keyframes menuAppear {
  0% {
    transform: translate(-50%,-50%) scale(0.3) rotate(-10deg);
    opacity: 0;
  }
  100% {
    transform: translate(-50%,-50%) scale(1) rotate(0deg);
    opacity: 1;
  }
}


/* small utility */
.hidden{display:none}
</style>
</head>
<body>

<!-- Main Menu -->
<div id="main-menu" class="main-menu">
  <div class="menu-title">2048</div>
  <div class="menu-subtitle">Classic & Chaos</div>
  <div class="menu-buttons">
    <button id="play-btn" class="menu-btn">üéÆ –ò–≥—Ä–∞—Ç—å</button>
    <button id="shop-menu-btn" class="menu-btn">üõçÔ∏è –ú–∞–≥–∞–∑–∏–Ω</button>
    <button id="results-menu-btn" class="menu-btn">üìä –†–µ–∑—É–ª—å—Ç–∞—Ç—ã</button>
  </div>
</div>

<!-- decorative animated background -->
<div class="bg-layer" aria-hidden="true">
  <!-- multiple fishes with varied delays/positions -->
  <div class="fish" style="left:-20%;top:10%;animation-delay:0s;opacity:0.12"></div>
  <div class="fish" style="left:-30%;top:35%;animation-duration:16s;animation-delay:-2s;opacity:0.09"></div>
  <div class="fish" style="left:-40%;top:60%;animation-duration:14s;animation-delay:-5s;opacity:0.1"></div>
  <!-- some bubbles -->
  <div class="bubble" style="left:10%; animation-duration:7s; animation-delay:0s;"></div>
  <div class="bubble" style="left:30%; animation-duration:9s; animation-delay:-2s; width:16px;height:16px;"></div>
  <div class="bubble" style="left:70%; animation-duration:6s; animation-delay:-3s;"></div>
  <div class="bubble" style="left:85%; animation-duration:11s; animation-delay:-1s;"></div>
</div>

<div class="app" role="application" aria-label="2048 game">
  <div class="header">
    <div>
      <div class="title">2048</div>
      <div class="subtitle">Classic & Chaos</div>
    </div>
    <div class="stats">
      <div class="score-pill">–°—á—ë—Ç: <span id="score">0</span></div>
      <div class="score-pill">–õ—É—á—à–∏–π: <span id="best-score">0</span></div>
      <div class="score-pill">–•–æ–¥—ã: <span id="moves">0</span></div>
      <div class="score-pill">–í—Ä–µ–º—è: <span id="time">00:00</span></div>
    </div>
  </div>

  <div class="controls" role="toolbar" aria-label="controls">
    <button id="back-to-menu" class="btn">üè† –ú–µ–Ω—é</button>
    <button id="mode-classic" class="mode-btn active">–ö–ª–∞—Å—Å–∏–∫–∞</button>
    <button id="mode-chaos" class="mode-btn">–•–∞–æ—Å</button>
    <button id="new-game-btn" class="btn">–ù–æ–≤–∞—è –∏–≥—Ä–∞</button>
  </div>

  <div class="board-wrap">
    <div class="board-shell" id="board-shell">
      <div id="game-board" class="board" aria-label="–∏–≥—Ä–æ–≤–∞—è –¥–æ—Å–∫–∞" tabindex="0"></div>
    </div>
    <div class="footer-note">–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Å—Ç—Ä–µ–ª–∫–∏, —Å–≤–∞–π–ø –∏–ª–∏ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ –º—ã—à—å—é.</div>
  </div>
</div>

<!-- Game Over Modal -->
<div id="modal-win" class="modal" aria-hidden="true">
  <h3>üéâ –ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º ‚Äî 2048 –¥–æ—Å—Ç–∏–≥–Ω—É—Ç!</h3>
  <p>–í–∞—à —Å—á—ë—Ç: <span id="win-score">0</span></p>
  <div style="display:flex;gap:8px;margin-top:10px">
    <button id="continue-btn" class="btn primary">–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å</button>
    <button id="new-game-win-btn" class="btn">–ù–æ–≤–∞—è –∏–≥—Ä–∞</button>
  </div>
</div>

<div id="modal-over" class="modal" aria-hidden="true">
  <h3>–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞</h3>
  <p>–°—á—ë—Ç: <span id="final-score">0</span></p>
  <p>–õ—É—á—à–∏–π: <span id="final-best">0</span></p>
  <div style="margin-top:10px"><button id="restart-btn" class="btn primary">–ó–∞–Ω–æ–≤–æ</button></div>
</div>

<!-- Results -->
<div id="results-panel" class="results-panel" aria-hidden="true">
  <h3>–ò—Å—Ç–æ—Ä–∏—è –∏–≥—Ä</h3>
  <ul id="results-list" style="max-height:300px;overflow:auto;margin-top:8px;padding-left:16px"></ul>
  <div style="margin-top:12px"><button id="close-results-btn" class="btn">–ó–∞–∫—Ä—ã—Ç—å</button></div>
</div>

<!-- Shop (simple placeholder for backgrounds) -->
<div id="shop-panel" class="results-panel" aria-hidden="true" style="max-width:520px">
  <h3>–ú–∞–≥–∞–∑–∏–Ω ‚Äî —Ñ–æ–Ω—ã</h3>
  <p>–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–æ–Ω (–ø—Ä–∏–º–µ—Ä). –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –ø–æ–¥–∫–ª—é—á–∏—Ç—å –æ–ø–ª–∞—Ç—É –ø–æ–∑–∂–µ.</p>
  <div style="display:flex;gap:12px;flex-wrap:wrap;margin-top:8px">
    <button class="btn set-bg" data-bg="default">–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é</button>
    <button class="btn set-bg" data-bg="ocean">–û–∫–µ–∞–Ω</button>
    <button class="btn set-bg" data-bg="coral">–ö–æ—Ä–∞–ª–ª—ã</button>
  </div>
  <div style="margin-top:12px"><button id="close-shop-btn" class="btn">–ó–∞–∫—Ä—ã—Ç—å</button></div>
</div>

<script>
/* ----------------- Game Engine 2048 (compact readable) --------------- */
/* Grid: 4x4
   Tiles: objects {id, value, r, c}
   Render: create background cells by CSS grid; tiles absolutely positioned via computed transforms.
   Movement: compute new grid and moves, animate by updating tile positions and using CSS transitions.
*/

(function(){
  const SIZE = 4;
  const STORAGE_KEY = 'milk2048_full_v1';
  const boardEl = document.getElementById('game-board');
  const scoreEl = document.getElementById('score');
  const bestEl = document.getElementById('best-score');
  const movesEl = document.getElementById('moves');
  const timeEl  = document.getElementById('time');

  const btnClassic = document.getElementById('mode-classic');
  const btnChaos   = document.getElementById('mode-chaos');
  const btnNew     = document.getElementById('new-game-btn');
  const resultsPanel = document.getElementById('results-panel');
  const resultsList = document.getElementById('results-list');
  const btnCloseRes = document.getElementById('close-results-btn');
  const shopPanel = document.getElementById('shop-panel');
  const closeShopBtn = document.getElementById('close-shop-btn');
  const backToMenuBtn = document.getElementById('back-to-menu');
  
  // Main menu elements
  const mainMenu = document.getElementById('main-menu');
  const playBtn = document.getElementById('play-btn');
  const shopMenuBtn = document.getElementById('shop-menu-btn');
  const resultsMenuBtn = document.getElementById('results-menu-btn');
  

  const modalOver = document.getElementById('modal-over');
  const modalWin = document.getElementById('modal-win');

  let grid = []; // 2d numeric
  let tiles = {}; // id -> tile object
  let nextId = 1;
  let score = 0;
  let best = parseInt(localStorage.getItem('milk2048_best') || '0',10) || 0;
  let moves = 0;
  let seconds = 0;
  let timer = null;
  let mode = 'classic'; // 'classic'|'chaos'
  let history = JSON.parse(localStorage.getItem('milk2048_history')||'[]');

  // sizes
  function computeCellSize(){
    const rect = boardEl.getBoundingClientRect();
    const gap = parseFloat(getComputedStyle(boardEl).getPropertyValue('gap') || 14);
    const padding = parseFloat(getComputedStyle(boardEl).getPropertyValue('padding') || 12);
    const totalGap = gap * (SIZE - 1);
    const avail = Math.min(rect.width, rect.height) - padding*2 - totalGap;
    const cell = avail / SIZE;
    return {cell, gap, padding, boardSize:rect};
  }

  /* helpers */
  function emptyGrid(){ return Array.from({length:SIZE},()=>Array(SIZE).fill(0)); }

  function saveState(){ 
    try{
      const data = {grid, tiles, nextId, score, best, moves, seconds, mode, history};
      localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
      localStorage.setItem('milk2048_best', String(best));
    }catch(e){}
  }
  function loadState(){
    try{
      const raw = localStorage.getItem(STORAGE_KEY);
      if(!raw) return false;
      const data = JSON.parse(raw);
      if(!data) return false;
      grid = data.grid || emptyGrid();
      tiles = data.tiles || {};
      nextId = data.nextId || 1;
      score = data.score || 0;
      best = data.best || best;
      moves = data.moves || 0;
      seconds = data.seconds || 0;
      mode = data.mode || 'classic';
      history = data.history || history;
      return true;
    }catch(e){return false;}
  }

  /* create a new tile object and attach to tiles map */
  function createTile(value, r, c, id){
    const tid = id || ('t'+(nextId++));
    const tile = { id:tid, value:value, r:r, c:c, willMerge:false, mergedTo:null };
    tiles[tid] = tile;
    grid[r][c] = tile.id;
    return tile;
  }

  /* add random tile to empty cell */
  function addRandom(){
    const empties=[];
    for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++) if(!grid[r][c]) empties.push({r,c});
    if(!empties.length) return false;
    const pos = empties[Math.floor(Math.random()*empties.length)];
    
    let v, specialType = null;
    
    if (mode === 'chaos') {
      // In chaos mode, add special tiles occasionally
      const rand = Math.random();
      if (rand < 0.05) { // 5% chance for special tile
        const specialTypes = ['bomb', 'multiplier', 'freeze', 'wildcard', 'shuffle', 'magnet', 'teleport', 'duplicator', 'vampire', 'shield'];
        specialType = specialTypes[Math.floor(Math.random() * specialTypes.length)];
        v = 0; // Special tiles have value 0 but special type
      } else if (rand < 0.1) { // 5% chance for higher value
        v = Math.random() < 0.5 ? 4 : 8;
      } else {
        v = Math.random() < 0.9 ? 2 : 4;
      }
    } else {
      // Classic mode - only regular tiles
      v = Math.random() < 0.9 ? 2 : 4;
    }
    
    const tile = createTile(v, pos.r, pos.c);
    if (specialType) {
      tile.specialType = specialType;
    }
    return true;
  }

  /* render background cells & tiles */
  function render(){
    // ensure background cells present (CSS grid provides layout) but we still clear board and add cells + tiles
    boardEl.innerHTML = '';
    // add 16 background cells via grid
    for(let i=0;i<SIZE*SIZE;i++){
      const el = document.createElement('div');
      el.className = 'cell';
      boardEl.appendChild(el);
    }
    // place tiles as absolutely positioned elements inside boardEl
    const sizes = computeCellSize();
    const cell = sizes.cell;
    const gap = sizes.gap;
    const padding = sizes.padding;

    // create DOM elements for each tile
    Object.values(tiles).forEach(t=>{
      // skip tiles that have been removed (value 0 or not in grid), but allow special tiles
      if(!t || (t.value<=0 && !t.specialType)) return;
      
      // Check if tile already exists in DOM
      let el = document.querySelector(`[data-id="${t.id}"]`);
      const isExisting = !!el;
      
      if (!el) {
        el = document.createElement('div');
        el.dataset.id = t.id;
        boardEl.appendChild(el);
      }
      
      // Set tile class based on value or special type
      if (t.specialType) {
        el.className = 'tile chaos-' + t.specialType;
      } else {
        el.className = 'tile v' + t.value;
      }
      
      if(t._new) el.classList.add('new');
      if(t._merge) el.classList.add('merge');
      if(t._moved && isExisting) el.classList.add('moving');
      if(t.frozen) el.classList.add('frozen');
      
      // Don't show text for special tiles (they have icons)
      if (!t.specialType) {
      el.textContent = t.value;
      }
      
      // compute translate based on row/col
      const x = padding + (cell+gap)*t.c;
      const y = padding + (cell+gap)*t.r;
      
      // Set position using CSS custom properties for animation compatibility
      el.style.setProperty('--tile-x', x + 'px');
      el.style.setProperty('--tile-y', y + 'px');
      
      // event: prevent dragging selection and handle special tile clicks (only in chaos mode)
      el.onmousedown = (e)=> {
        e.preventDefault();
        if (t.specialType && mode === 'chaos') {
          handleSpecialTileClick(t);
        }
      };
      
      // Remove movement class after animation
      if (t._moved && isExisting) {
        setTimeout(() => {
          el.classList.remove('moving');
          t._moved = false;
        }, 300);
      }
    });

    // update scores ui
    scoreEl.textContent = score;
    bestEl.textContent = best;
    movesEl.textContent = moves;
    timeEl.textContent = formatTime(seconds);
  }

  function formatTime(sec){
    const mm = String(Math.floor(sec/60)).padStart(2,'0');
    const ss = String(sec%60).padStart(2,'0');
    return mm+':'+ss;
  }

  // Handle special tile clicks
  function handleSpecialTileClick(tile) {
    switch(tile.specialType) {
      case 'freeze':
        freezeAdjacentTiles(tile);
        break;
      case 'shuffle':
        shuffleAllTiles();
        break;
      case 'multiplier':
        multiplyNearestTile(tile);
        break;
      case 'magnet':
        magnetizeTiles(tile);
        break;
      case 'teleport':
        teleportRandomTile(tile);
        break;
      case 'duplicator':
        duplicateAdjacentTile(tile);
        break;
      case 'vampire':
        vampireEffect(tile);
        break;
      case 'shield':
        shieldEffect(tile);
        break;
    }
    // Remove the used special tile
    delete tiles[tile.id];
    grid[tile.r][tile.c] = 0;
    render();
  }

  function freezeAdjacentTiles(tile) {
    const directions = [[-1,0],[1,0],[0,-1],[0,1]];
    directions.forEach(([dr, dc]) => {
      const newR = tile.r + dr;
      const newC = tile.c + dc;
      if (newR >= 0 && newR < SIZE && newC >= 0 && newC < SIZE) {
        const targetId = grid[newR][newC];
        if (targetId && tiles[targetId] && !tiles[targetId].specialType) {
          tiles[targetId].frozen = true;
          tiles[targetId].frozenTurns = 3; // Frozen for 3 turns
        }
      }
    });
  }

  function shuffleAllTiles() {
    const allTiles = Object.values(tiles).filter(t => t && t.value > 0 && !t.specialType);
    const positions = [];
    for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++) if(!grid[r][c]) positions.push({r,c});
    
    // Shuffle positions
    for(let i = positions.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [positions[i], positions[j]] = [positions[j], positions[i]];
    }
    
    // Assign new positions
    allTiles.forEach((tile, index) => {
      if (index < positions.length) {
        const newPos = positions[index];
        grid[tile.r][tile.c] = 0;
        tile.r = newPos.r;
        tile.c = newPos.c;
        grid[newPos.r][newPos.c] = tile.id;
      }
    });
  }

  function multiplyNearestTile(tile) {
    const directions = [[-1,0],[1,0],[0,-1],[0,1]];
    let nearestTile = null;
    let minDistance = Infinity;
    
    directions.forEach(([dr, dc]) => {
      const newR = tile.r + dr;
      const newC = tile.c + dc;
      if (newR >= 0 && newR < SIZE && newC >= 0 && newC < SIZE) {
        const targetId = grid[newR][newC];
        if (targetId && tiles[targetId] && tiles[targetId].value > 0 && !tiles[targetId].specialType) {
          const distance = Math.abs(dr) + Math.abs(dc);
          if (distance < minDistance) {
            minDistance = distance;
            nearestTile = tiles[targetId];
          }
        }
      }
    });
    
    if (nearestTile) {
      const multiplier = 2 + Math.floor(Math.random() * 3); // 2, 3, or 4
      nearestTile.value *= multiplier;
      score += nearestTile.value;
    }
  }

  // Process frozen tiles and shields
  function processFrozenTiles() {
    Object.values(tiles).forEach(tile => {
      if (tile && tile.frozen && tile.frozenTurns > 0) {
        tile.frozenTurns--;
        if (tile.frozenTurns <= 0) {
          tile.frozen = false;
        }
      }
      if (tile && tile.shielded && tile.shieldTurns > 0) {
        tile.shieldTurns--;
        if (tile.shieldTurns <= 0) {
          tile.shielded = false;
        }
      }
    });
  }

  // Check for auto-triggering special tiles when they touch regular tiles
  function checkSpecialTileTriggers() {
    const specialTiles = Object.values(tiles).filter(t => t && t.specialType);
    
    specialTiles.forEach(specialTile => {
      const directions = [[-1,0],[1,0],[0,-1],[0,1]];
      let hasAdjacentRegular = false;
      
      // Check if there are regular tiles adjacent to this special tile
      directions.forEach(([dr, dc]) => {
        const newR = specialTile.r + dr;
        const newC = specialTile.c + dc;
        if (newR >= 0 && newR < SIZE && newC >= 0 && newC < SIZE) {
          const targetId = grid[newR][newC];
          if (targetId && tiles[targetId] && tiles[targetId].value > 0 && !tiles[targetId].specialType && !tiles[targetId].shielded) {
            hasAdjacentRegular = true;
          }
        }
      });
      
      // Auto-trigger the special tile if it has adjacent regular tiles
      if (hasAdjacentRegular) {
        handleSpecialTileClick(specialTile);
      }
    });
  }

  // Process special tiles effects in chaos mode
  function processSpecialTiles() {
    const specialTiles = Object.values(tiles).filter(t => t && t.specialType);
    
    specialTiles.forEach(tile => {
      switch(tile.specialType) {
        case 'bomb':
          // Bomb explodes and removes surrounding tiles
          explodeBomb(tile);
          break;
        case 'multiplier':
          // Multiplier doubles adjacent tiles
          multiplyAdjacent(tile);
          break;
        case 'freeze':
          // Freeze prevents movement for a few turns
          freezeBoard();
          break;
        case 'wildcard':
          // Wildcard can merge with any tile
          wildcardEffect(tile);
          break;
      }
    });
  }

  function explodeBomb(tile) {
    const directions = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
    directions.forEach(([dr, dc]) => {
      const newR = tile.r + dr;
      const newC = tile.c + dc;
      if (newR >= 0 && newR < SIZE && newC >= 0 && newC < SIZE) {
        const targetId = grid[newR][newC];
        if (targetId && tiles[targetId]) {
          delete tiles[targetId];
          grid[newR][newC] = 0;
        }
      }
    });
    // Remove the bomb itself
    delete tiles[tile.id];
    grid[tile.r][tile.c] = 0;
  }

  function multiplyAdjacent(tile) {
    const directions = [[-1,0],[1,0],[0,-1],[0,1]];
    directions.forEach(([dr, dc]) => {
      const newR = tile.r + dr;
      const newC = tile.c + dc;
      if (newR >= 0 && newR < SIZE && newC >= 0 && newC < SIZE) {
        const targetId = grid[newR][newC];
        if (targetId && tiles[targetId] && tiles[targetId].value > 0) {
          tiles[targetId].value *= 2;
          score += tiles[targetId].value;
        }
      }
    });
    // Remove the multiplier
    delete tiles[tile.id];
    grid[tile.r][tile.c] = 0;
  }

  function freezeBoard() {
    // Add freeze effect - could be implemented as a temporary state
    console.log('Board frozen!');
  }

  function wildcardEffect(tile) {
    // Wildcard can merge with any adjacent tile
    const directions = [[-1,0],[1,0],[0,-1],[0,1]];
    for (const [dr, dc] of directions) {
      const newR = tile.r + dr;
      const newC = tile.c + dc;
      if (newR >= 0 && newR < SIZE && newC >= 0 && newC < SIZE) {
        const targetId = grid[newR][newC];
        if (targetId && tiles[targetId] && tiles[targetId].value > 0) {
          // Merge with the first adjacent tile found
          tiles[targetId].value *= 2;
          score += tiles[targetId].value;
          delete tiles[tile.id];
          grid[tile.r][tile.c] = 0;
          break;
        }
      }
    }
  }

  // New special tile effects
  function magnetizeTiles(tile) {
    // Magnet attracts all tiles towards it
    const directions = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
    directions.forEach(([dr, dc]) => {
      const newR = tile.r + dr;
      const newC = tile.c + dc;
      if (newR >= 0 && newR < SIZE && newC >= 0 && newC < SIZE) {
        const targetId = grid[newR][newC];
        if (targetId && tiles[targetId] && tiles[targetId].value > 0 && !tiles[targetId].specialType) {
          // Move tile towards magnet
          grid[newR][newC] = 0;
          tiles[targetId].r = tile.r;
          tiles[targetId].c = tile.c;
          grid[tile.r][tile.c] = targetId;
        }
      }
    });
  }

  function teleportRandomTile(tile) {
    // Teleport a random tile to a random empty position
    const allTiles = Object.values(tiles).filter(t => t && t.value > 0 && !t.specialType);
    if (allTiles.length === 0) return;
    
    const randomTile = allTiles[Math.floor(Math.random() * allTiles.length)];
    const emptyPositions = [];
    for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++) if(!grid[r][c]) emptyPositions.push({r,c});
    
    if (emptyPositions.length > 0) {
      const newPos = emptyPositions[Math.floor(Math.random() * emptyPositions.length)];
      grid[randomTile.r][randomTile.c] = 0;
      randomTile.r = newPos.r;
      randomTile.c = newPos.c;
      grid[newPos.r][newPos.c] = randomTile.id;
    }
  }

  function duplicateAdjacentTile(tile) {
    // Duplicate the highest value adjacent tile
    const directions = [[-1,0],[1,0],[0,-1],[0,1]];
    let highestTile = null;
    let highestValue = 0;
    
    directions.forEach(([dr, dc]) => {
      const newR = tile.r + dr;
      const newC = tile.c + dc;
      if (newR >= 0 && newR < SIZE && newC >= 0 && newC < SIZE) {
        const targetId = grid[newR][newC];
        if (targetId && tiles[targetId] && tiles[targetId].value > highestValue && !tiles[targetId].specialType) {
          highestValue = tiles[targetId].value;
          highestTile = tiles[targetId];
        }
      }
    });
    
    if (highestTile) {
      // Find empty position for duplicate
      const emptyPositions = [];
      for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++) if(!grid[r][c]) emptyPositions.push({r,c});
      
      if (emptyPositions.length > 0) {
        const newPos = emptyPositions[Math.floor(Math.random() * emptyPositions.length)];
        createTile(highestTile.value, newPos.r, newPos.c);
      }
    }
  }

  function vampireEffect(tile) {
    // Vampire steals half the value from adjacent tiles
    const directions = [[-1,0],[1,0],[0,-1],[0,1]];
    let stolenValue = 0;
    
    directions.forEach(([dr, dc]) => {
      const newR = tile.r + dr;
      const newC = tile.c + dc;
      if (newR >= 0 && newR < SIZE && newC >= 0 && newC < SIZE) {
        const targetId = grid[newR][newC];
        if (targetId && tiles[targetId] && tiles[targetId].value > 0 && !tiles[targetId].specialType) {
          const halfValue = Math.floor(tiles[targetId].value / 2);
          tiles[targetId].value -= halfValue;
          stolenValue += halfValue;
        }
      }
    });
    
    if (stolenValue > 0) {
      score += stolenValue;
    }
  }

  function shieldEffect(tile) {
    // Shield protects adjacent tiles from being affected by other special tiles for 3 turns
    const directions = [[-1,0],[1,0],[0,-1],[0,1]];
    directions.forEach(([dr, dc]) => {
      const newR = tile.r + dr;
      const newC = tile.c + dc;
      if (newR >= 0 && newR < SIZE && newC >= 0 && newC < SIZE) {
        const targetId = grid[newR][newC];
        if (targetId && tiles[targetId] && !tiles[targetId].specialType) {
          tiles[targetId].shielded = true;
          tiles[targetId].shieldTurns = 3;
        }
      }
    });
  }

  // Particle effect for merges
  function createParticles(x, y, color) {
    const particleContainer = document.createElement('div');
    particleContainer.style.position = 'absolute';
    particleContainer.style.left = x + 'px';
    particleContainer.style.top = y + 'px';
    particleContainer.style.pointerEvents = 'none';
    particleContainer.style.zIndex = '20';
    boardEl.appendChild(particleContainer);

    for (let i = 0; i < 8; i++) {
      const particle = document.createElement('div');
      particle.style.position = 'absolute';
      particle.style.width = '4px';
      particle.style.height = '4px';
      particle.style.background = color;
      particle.style.borderRadius = '50%';
      particle.style.left = '50%';
      particle.style.top = '50%';
      
      const angle = (i / 8) * Math.PI * 2;
      const distance = 20 + Math.random() * 30;
      const duration = 0.6 + Math.random() * 0.4;
      
      particle.style.transform = `translate(-50%, -50%) translate(${Math.cos(angle) * distance}px, ${Math.sin(angle) * distance}px)`;
      particle.style.transition = `all ${duration}s ease-out`;
      particle.style.opacity = '1';
      
      particleContainer.appendChild(particle);
      
      setTimeout(() => {
        particle.style.opacity = '0';
        particle.style.transform = `translate(-50%, -50%) translate(${Math.cos(angle) * distance * 2}px, ${Math.sin(angle) * distance * 2}px) scale(0)`;
      }, 50);
    }
    
    setTimeout(() => {
      if (particleContainer.parentNode) {
        particleContainer.parentNode.removeChild(particleContainer);
      }
    }, 1000);
  }

  /* movement core:
     returns true if any tile moved or merged.
     Fixed movement logic based on working script.js
  */
  function move(dir){
    // dir: 'left','right','up','down'
    let moved = false;
    // reset merge flags
    Object.values(tiles).forEach(t => { if(t) { t.willMerge=false; t.mergedTo=null; t._merge=false; t._new=false; } });

    // Process each row or column based on direction
    if(dir === 'left' || dir === 'right'){
      // Process rows
      for(let r = 0; r < SIZE; r++){
        // Build the line with tiles in correct order
        const line = [];
        for(let c = 0; c < SIZE; c++){
          const id = grid[r][c];
          line.push(id ? tiles[id] : null);
        }
        
        // Reverse for right direction
        const read = (dir === 'left') ? line : line.slice().reverse();
        
        // Filter out nulls to get compact array, but keep special tiles
        const compact = read.filter(x => x && (x.value > 0 || x.specialType));
        
        // Process merges
        const processed = [];
        for(let i = 0; i < compact.length; i++){
          // Only merge regular tiles (not special tiles)
          if(i + 1 < compact.length && 
             compact[i].value === compact[i + 1].value && 
             compact[i].value > 0 && 
             !compact[i].specialType && 
             !compact[i + 1].specialType){
            // Merge tiles
            compact[i].value *= 2;
            compact[i].willMerge = true;
            compact[i]._merge = true;
            score += compact[i].value;
            if(score > best){ best = score; localStorage.setItem('milk2048_best',String(best)); }
            // Mark for removal
            processed.push({tile: compact[i], merged: true, removed: compact[i + 1]});
            i++; // Skip next tile
          } else {
            // Check for special tile effects in chaos mode
            if (mode === 'chaos' && compact[i].specialType) {
              processed.push({tile: compact[i], merged: false, special: true});
          } else {
            processed.push({tile: compact[i], merged: false});
            }
          }
        }
        
        // Fill with nulls to size
        while(processed.length < SIZE) processed.push(null);
        
        // Map back to positions
        for(let idx = 0; idx < SIZE; idx++){
          const targetIndex = (dir === 'left') ? idx : (SIZE - 1 - idx);
          const item = processed[idx];
          if(item){
            const tile = item.tile;
            const from = {r: tile.r, c: tile.c};
            const to = {r: r, c: targetIndex};
            
            // Update tile position
            tile.r = to.r;
            tile.c = to.c;
            
            // Check if moved
            if(from.r !== to.r || from.c !== to.c || item.merged){
              moved = true;
              // Mark tile as moved for animation
              if(from.r !== to.r || from.c !== to.c) {
                tile._moved = true;
              }
              // Add particle effect for merges
              if(item.merged) {
                const sizes = computeCellSize();
                const x = sizes.padding + (sizes.cell + sizes.gap) * to.c + sizes.cell / 2;
                const y = sizes.padding + (sizes.cell + sizes.gap) * to.r + sizes.cell / 2;
                const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57'];
                createParticles(x, y, colors[Math.floor(Math.random() * colors.length)]);
              }
            }
            
            // Remove merged tile
            if(item.removed){
              delete tiles[item.removed.id];
            }
          }
        }
      }
    } else {
      // Process columns (up/down)
      for(let c = 0; c < SIZE; c++){
        // Build the column with tiles in correct order
        const col = [];
        for(let r = 0; r < SIZE; r++){
          const id = grid[r][c];
          col.push(id ? tiles[id] : null);
        }
        
        // Reverse for down direction
        const read = (dir === 'up') ? col : col.slice().reverse();
        
        // Filter out nulls to get compact array, but keep special tiles
        const compact = read.filter(x => x && (x.value > 0 || x.specialType));
        
        // Process merges
        const processed = [];
        for(let i = 0; i < compact.length; i++){
          // Only merge regular tiles (not special tiles)
          if(i + 1 < compact.length && 
             compact[i].value === compact[i + 1].value && 
             compact[i].value > 0 && 
             !compact[i].specialType && 
             !compact[i + 1].specialType){
            // Merge tiles
            compact[i].value *= 2;
            compact[i].willMerge = true;
            compact[i]._merge = true;
            score += compact[i].value;
            if(score > best){ best = score; localStorage.setItem('milk2048_best',String(best)); }
            // Mark for removal
            processed.push({tile: compact[i], merged: true, removed: compact[i + 1]});
            i++; // Skip next tile
          } else {
            // Check for special tile effects in chaos mode
            if (mode === 'chaos' && compact[i].specialType) {
              processed.push({tile: compact[i], merged: false, special: true});
          } else {
            processed.push({tile: compact[i], merged: false});
            }
          }
        }
        
        // Fill with nulls to size
        while(processed.length < SIZE) processed.push(null);
        
        // Map back to positions
        for(let idx = 0; idx < SIZE; idx++){
          const targetIndex = (dir === 'up') ? idx : (SIZE - 1 - idx);
          const item = processed[idx];
          if(item){
            const tile = item.tile;
            const from = {r: tile.r, c: tile.c};
            const to = {r: targetIndex, c: c};
            
            // Update tile position
            tile.r = to.r;
            tile.c = to.c;
            
            // Check if moved
            if(from.r !== to.r || from.c !== to.c || item.merged){
              moved = true;
              // Mark tile as moved for animation
              if(from.r !== to.r || from.c !== to.c) {
                tile._moved = true;
              }
              // Add particle effect for merges
              if(item.merged) {
                const sizes = computeCellSize();
                const x = sizes.padding + (sizes.cell + sizes.gap) * to.c + sizes.cell / 2;
                const y = sizes.padding + (sizes.cell + sizes.gap) * to.r + sizes.cell / 2;
                const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57'];
                createParticles(x, y, colors[Math.floor(Math.random() * colors.length)]);
              }
            }
            
            // Remove merged tile
            if(item.removed){
              delete tiles[item.removed.id];
            }
          }
        }
      }
    }

    // Rebuild grid from updated tile positions
    const newGrid = emptyGrid();
    Object.values(tiles).forEach(tile => {
      if(tile && tile.r >= 0 && tile.r < SIZE && tile.c >= 0 && tile.c < SIZE){
        newGrid[tile.r][tile.c] = tile.id;
      }
    });
    grid = newGrid;

    // add random tile after move if moved
    if(moved){
      moves++;
      
      // Add moving effect to board
      boardEl.classList.add('moving');
      setTimeout(() => boardEl.classList.remove('moving'), 300);
      
      // small delay for animations: we'll render intermediate then add new tile after short timeout
      // But for simplicity call addRandom then render ‚Äî but we want new tile to appear with .new class.
      const added = addRandom();
      // Process special tile effects only in chaos mode
      if(mode === 'chaos'){
        processSpecialTiles();
        processFrozenTiles();
        checkSpecialTileTriggers(); // Check for auto-triggering special tiles
      }

      // after moves update best if needed
      if(score > best) { best = score; localStorage.setItem('milk2048_best',String(best)); }

      render();
      saveState();

      // check game over / win
      setTimeout(()=>{
        if(checkWin()) { showWin(); saveHistory(); saveState(); return; }
        if(!canMove()) { showGameOver(); saveHistory(); saveState(); return; }
      }, 120);
    }

    return moved;
  }

  /* detect win (2048 exists) */
  function checkWin(){
    for(const id in tiles){
      if(tiles[id] && tiles[id].value >= 2048 && !tiles[id].specialType) return true;
    }
    return false;
  }

  function canMove(){
    // any empty?
    for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++) if(!grid[r][c]) return true;
    // neighbors (only check regular tiles)
    for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++){
      const id = grid[r][c]; if(!id) continue;
      const tile = tiles[id];
      if(!tile || tile.specialType || tile.value <= 0) continue;
      const v = tile.value;
      const dirs = [[1,0],[0,1]];
      for(const d of dirs){
        const rr=r+d[0], cc=c+d[1];
        if(rr>=0&&rr<SIZE&&cc>=0&&cc<SIZE){
          const id2 = grid[rr][cc];
          if(id2 && tiles[id2] && tiles[id2].value === v && !tiles[id2].specialType) return true;
        }
      }
    }
    return false;
  }

  function saveHistory(){
    history = JSON.parse(localStorage.getItem('milk2048_history')||'[]');
    history.push({date:new Date().toLocaleString(), score, moves, time:formatTime(seconds), mode});
    localStorage.setItem('milk2048_history', JSON.stringify(history));
  }

  /* UI modals */
  function showGameOver(){
    document.getElementById('final-score').textContent = score;
    document.getElementById('final-best').textContent = best;
    modalOver.style.display = 'block';
    modalOver.setAttribute('aria-hidden','false');
  }
  function hideGameOver(){
    modalOver.style.display = 'none';
    modalOver.setAttribute('aria-hidden','true');
  }
  function showWin(){
    document.getElementById('win-score').textContent = score;
    modalWin.style.display = 'block';
    modalWin.setAttribute('aria-hidden','false');
    // confetti simple: add small colored emojis for short time
    const conf = document.createElement('div');
    conf.style.position='fixed'; conf.style.left='0'; conf.style.top='0'; conf.style.width='100%'; conf.style.height='100%'; conf.style.pointerEvents='none'; conf.style.zIndex=60;
    for(let i=0;i<30;i++){
      const s = document.createElement('div');
      s.textContent = 'üéâ';
      s.style.position='absolute';
      s.style.left = Math.random()*100 + '%';
      s.style.top = Math.random()*30 + '%';
      s.style.fontSize = (10+Math.random()*30)+'px';
      s.style.opacity = '0';
      s.style.transform = 'translateY(-10px) rotate('+Math.random()*180+'deg)';
      s.style.transition='all 1s linear';
      conf.appendChild(s);
      setTimeout(()=> { s.style.opacity='1'; s.style.transform='translateY(80vh) rotate('+ (360+Math.random()*360) +'deg)'; }, 50+i*10);
    }
    document.body.appendChild(conf);
    setTimeout(()=> document.body.removeChild(conf), 1600);
  }
  function hideWin(){ modalWin.style.display='none'; modalWin.setAttribute('aria-hidden','true'); }

  /* new game */
  function startNew(savePrev=true){
    if(savePrev && score>0) saveHistory();
    // clear
    grid = emptyGrid();
    tiles = {};
    nextId = 1;
    score = 0; moves = 0; seconds = 0;
    stopTimer(); startTimer();
    // create two random tiles
    addRandom(); addRandom();
    render(); saveState();
    hideGameOver(); hideWin();
  }

  /* timer */
  function startTimer(){ if(timer) clearInterval(timer); timer = setInterval(()=>{ seconds++; timeEl.textContent = formatTime(seconds); saveState(); },1000); }
  function stopTimer(){ if(timer){ clearInterval(timer); timer=null; } }

  /* results panel */
  function openResults(){
    resultsList.innerHTML = '';
    const arr = JSON.parse(localStorage.getItem('milk2048_history')||'[]')
      .slice()
      .filter(item => item.score >= 500) // Only show scores 500 and above
      .sort((a, b) => b.score - a.score); // Sort from best to worst
    if(arr.length===0){ const li=document.createElement('li'); li.textContent='–ü–æ–∫–∞ –Ω–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –æ—Ç 500'; resultsList.appendChild(li); }
    else arr.slice(0,50).forEach(it=>{
      const li=document.createElement('li');
      li.textContent = it.score; // Show only scores
      resultsList.appendChild(li);
    });
    resultsPanel.classList.add('active'); resultsPanel.setAttribute('aria-hidden','false');
  }
  function closeResults(){ resultsPanel.classList.remove('active'); resultsPanel.setAttribute('aria-hidden','true'); }

  /* shop */
  function openShop(){ shopPanel.classList.add('active'); shopPanel.setAttribute('aria-hidden','false'); }
  function closeShop(){ shopPanel.classList.remove('active'); shopPanel.setAttribute('aria-hidden','true'); }

  /* main menu */
  function showMainMenu(){ 
    mainMenu.classList.remove('hidden'); 
    document.querySelector('.app').style.display = 'none';
  }
  function hideMainMenu(){ 
    mainMenu.classList.add('hidden'); 
    document.querySelector('.app').style.display = 'block';
  }
  function startGameFromMenu(){
    hideMainMenu();
    startNew(true);
  }


  /* attach events */
  btnNew.addEventListener('click', ()=> startNew(true));
  btnClassic.addEventListener('click', ()=> { mode='classic'; btnClassic.classList.add('active'); btnChaos.classList.remove('active'); startNew(true); });
  btnChaos.addEventListener('click', ()=> { mode='chaos'; btnChaos.classList.add('active'); btnClassic.classList.remove('active'); startNew(true); });
  btnCloseRes.addEventListener('click', closeResults);
  closeShopBtn.addEventListener('click', closeShop);
  backToMenuBtn.addEventListener('click', showMainMenu);

  // Main menu event listeners
  playBtn.addEventListener('click', startGameFromMenu);
  shopMenuBtn.addEventListener('click', ()=>{ hideMainMenu(); openShop(); });
  resultsMenuBtn.addEventListener('click', ()=>{ hideMainMenu(); openResults(); });


  document.getElementById('restart-btn').addEventListener('click', ()=>{ hideGameOver(); startNew(true); });
  document.getElementById('continue-btn').addEventListener('click', ()=>{ hideWin(); });
  document.getElementById('new-game-win-btn').addEventListener('click', ()=>{ hideWin(); startNew(true); });

  // Function to clear background elements
  function clearBackgroundElements() {
    const bgLayer = document.querySelector('.bg-layer');
    if (bgLayer) {
      // Remove all existing animated elements except fish and bubbles
      const elementsToRemove = bgLayer.querySelectorAll('.coral, .dolphin, .shark');
      elementsToRemove.forEach(el => el.remove());
    }
  }

  // Function to create coral elements
  function createCorals() {
    const bgLayer = document.querySelector('.bg-layer');
    if (!bgLayer) return;
    
    for (let i = 0; i < 6; i++) {
      const coral = document.createElement('div');
      coral.className = 'coral';
      coral.style.left = Math.random() * 80 + 10 + '%';
      coral.style.animationDelay = Math.random() * 4 + 's';
      coral.style.animationDuration = (3 + Math.random() * 2) + 's';
      bgLayer.appendChild(coral);
    }
  }

  // Function to create ocean creatures
  function createOceanCreatures() {
    const bgLayer = document.querySelector('.bg-layer');
    if (!bgLayer) return;
    
    // Create dolphins
    for (let i = 0; i < 3; i++) {
      const dolphin = document.createElement('div');
      dolphin.className = 'dolphin';
      dolphin.style.top = Math.random() * 60 + 20 + '%';
      dolphin.style.animationDelay = Math.random() * 8 + 's';
      dolphin.style.animationDuration = (6 + Math.random() * 4) + 's';
      bgLayer.appendChild(dolphin);
    }
    
    // Create sharks
    for (let i = 0; i < 2; i++) {
      const shark = document.createElement('div');
      shark.className = 'shark';
      shark.style.top = Math.random() * 40 + 30 + '%';
      shark.style.animationDelay = Math.random() * 12 + 's';
      shark.style.animationDuration = (10 + Math.random() * 4) + 's';
      bgLayer.appendChild(shark);
    }
  }

  // shop bg selection (placeholder)
  document.querySelectorAll('.set-bg').forEach(b=>{
    b.addEventListener('click', (e)=>{
      const v = e.currentTarget.dataset.bg;
      clearBackgroundElements();
      
      if(v==='ocean'){
        document.body.style.background = 'linear-gradient(180deg,#bce5f8,#9fd7f7 60%)';
        createOceanCreatures();
      } else if(v==='coral'){
        document.body.style.background = 'linear-gradient(180deg,#ffd3c0,#ffd9e0 60%)';
        createCorals();
      } else {
        document.body.style.background = 'linear-gradient(180deg,var(--bg-1),#cfe9f9 60%)';
      }
    });
  });

  /* keyboard controls */
  document.addEventListener('keydown', (e)=>{
    if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)){
      e.preventDefault();
      const map = { ArrowUp:'up', ArrowDown:'down', ArrowLeft:'left', ArrowRight:'right' };
      const moved = move(map[e.key]);
      if(moved) render();
      saveState();
    }
  });

  /* swipe / drag support for touch and mouse */
  (function initPointer(){
    let startX=0, startY=0, isDown=false, moved=false;
    // touch
    boardEl.addEventListener('touchstart', (ev)=>{
      const t = ev.touches && ev.touches[0];
      if(!t) return;
      startX = t.clientX; startY = t.clientY;
    }, {passive:true});
    boardEl.addEventListener('touchend', (ev)=>{
      const t = ev.changedTouches && ev.changedTouches[0];
      if(!t) return;
      const dx = t.clientX - startX, dy = t.clientY - startY;
      const adx = Math.abs(dx), ady = Math.abs(dy);
      const TH = 24;
      if(adx < TH && ady < TH) return;
      const dir = (adx>ady) ? (dx<0 ? 'left':'right') : (dy<0? 'up':'down');
      const moved = move(dir);
      if(moved) render();
      saveState();
    }, {passive:true});

    // mouse drag for desktop (mousedown -> mouseup)
    boardEl.addEventListener('mousedown', (ev)=>{
      isDown=true; startX=ev.clientX; startY=ev.clientY; moved=false;
    });
    document.addEventListener('mouseup', (ev)=>{
      if(!isDown) return; isDown=false;
      const dx = ev.clientX - startX, dy = ev.clientY - startY;
      const adx=Math.abs(dx), ady=Math.abs(dy);
      const TH=12;
      if(adx<TH && ady<TH) return;
      const dir = (adx>ady)? (dx<0?'left':'right') : (dy<0?'up':'down');
      const m = move(dir);
      if(m) render();
      saveState();
    });
  })();

  /* initial load or start new */
  const loaded = loadState();
  if(!loaded){
    // Show main menu on first load
    showMainMenu();
    grid = emptyGrid();
    addRandom(); addRandom();
    startTimer();
    render();
    saveState();
  } else {
    // restore tile objects into grid (if tiles map saved)
    // If we loaded board and tiles map, we need to ensure grid references tile IDs
    // But our save stores grid and tiles; tiles ids may be serialized as object keys; ensure functions work.
    startTimer();
    render();
  }

  /* check win/over after restore - only if game is in progress */
  setTimeout(()=>{
    // Only show win/over modals if there are tiles on the board (game in progress)
    const hasTiles = Object.values(tiles).some(t => t && t.value > 0);
    if(hasTiles){
    if(checkWin()){ showWin(); }
    else if(!canMove()){ showGameOver(); }
    }
  },80);

  /* utility: when window resizes, re-render for correct transforms */
  window.addEventListener('resize', ()=> render());

  /* small accessibility: clicking outside panels closes them */
  window.addEventListener('click', (e)=>{
    if(e.target === resultsPanel) closeResults();
    if(e.target === shopPanel) closeShop();
  });

})();
</script>
</body>
</html>

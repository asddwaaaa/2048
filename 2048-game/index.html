<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>2048 ‚Äî –ü—Ä–æ—Å—Ç–∞—è –∏–≥—Ä–∞</title>
<style>
:root {
  --bg-primary: #f5e6d3;
  --bg-secondary: #e6d5c1;
  --cell-bg: #d4c4b0;
  --tile-2: #f0e5d3;
  --tile-4: #e6d5c1;
  --tile-8: #d4c4b0;
  --tile-16: #c5b49c;
  --tile-32: #b8a68a;
  --tile-64: #ab9678;
  --tile-128: #9e8666;
  --tile-256: #917654;
  --tile-512: #846642;
  --tile-1024: #775630;
  --tile-2048: #6b4620;
  --text-dark: #4a3c28;
  --text-light: #f5e6d3;
  --accent: #8b7355;
  --shadow: rgba(0,0,0,0.1);
}

/* –¢–µ–º—ã */
.theme-dark {
  --bg-primary: #2d2d2d;
  --bg-secondary: #3a3a3a;
  --cell-bg: #2a2a2a;
  --tile-2: #4a4a4a;
  --tile-4: #5a5a5a;
  --tile-8: #6a6a6a;
  --tile-16: #7a7a7a;
  --tile-32: #8a8a8a;
  --tile-64: #9a9a9a;
  --tile-128: #8b7355;
  --tile-256: #9d8567;
  --tile-512: #af9779;
  --tile-1024: #c1a98b;
  --tile-2048: #d3bb9d;
  --text-dark: #f0e6d3;
  --text-light: #2d2d2d;
  --accent: #d3bb9d;
}

.theme-ocean {
  --bg-primary: #e0f2f1;
  --bg-secondary: #b2ebf2;
  --cell-bg: #a5d6d6;
  --tile-2: #80deea;
  --tile-4: #4dd0e1;
  --tile-8: #26c6da;
  --tile-16: #00bcd4;
  --tile-32: #00acc1;
  --tile-64: #0097a7;
  --tile-128: #00838f;
  --tile-256: #006064;
  --tile-512: #004d40;
  --tile-1024: #00695c;
  --tile-2048: #00796b;
  --text-dark: #004d40;
  --text-light: #e0f2f1;
  --accent: #00838f;
}

.theme-forest {
  --bg-primary: #e8f5e8;
  --bg-secondary: #c8e6c9;
  --cell-bg: #a5d6a7;
  --tile-2: #a5d6a7;
  --tile-4: #81c784;
  --tile-8: #66bb6a;
  --tile-16: #4caf50;
  --tile-32: #43a047;
  --tile-64: #388e3c;
  --tile-128: #2e7d32;
  --tile-256: #1b5e20;
  --tile-512: #2e7d32;
  --tile-1024: #388e3c;
  --tile-2048: #4caf50;
  --text-dark: #1b5e20;
  --text-light: #e8f5e8;
  --accent: #4caf50;
}

* { 
  box-sizing: border-box; 
  margin: 0; 
  padding: 0; 
}

html, body {
  overflow: hidden;
  height: 100%;
  overscroll-behavior: none;
  -webkit-overflow-scrolling: auto;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
  background: var(--bg-primary);
  color: var(--text-dark);
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  padding: 20px;
  transition: background 0.3s ease;
  touch-action: none;
  -webkit-user-select: none;
  -webkit-touch-callout: none;
  -webkit-tap-highlight-color: transparent;
}

.container {
  width: 100%;
  max-width: 500px;
  text-align: center;
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  gap: 10px;
}

h1 {
  font-size: 52px;
  font-weight: 700;
  color: var(--accent);
  text-shadow: 
    0 2px 0 rgba(0,0,0,0.25),
    0 4px 0 rgba(0,0,0,0.15),
    0 6px 0 rgba(0,0,0,0.1),
    0 8px 8px var(--shadow);
  transform: perspective(500px) rotateX(15deg);
  -webkit-user-select: none;
  user-select: none;
}

@media (max-width: 480px) {
  h1 { font-size: 40px; }
}

.score-container {
  display: flex;
  gap: 10px;
}

.score-box {
  background: var(--bg-secondary);
  padding: 10px 16px;
  border-radius: 8px;
  font-size: 14px;
  font-weight: 600;
}

.score-value {
  font-size: 20px;
  font-weight: 700;
  display: block;
}

.controls {
  display: flex;
  gap: 10px;
  margin-bottom: 20px;
  justify-content: center;
  flex-wrap: wrap;
}

button {
  background: var(--accent);
  color: var(--text-light);
  border: none;
  padding: 10px 20px;
  border-radius: 8px;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: transform 0.2s, opacity 0.2s;
  -webkit-tap-highlight-color: transparent;
}

button:active {
  transform: scale(0.95);
}

select {
  background: var(--bg-secondary);
  color: var(--text-dark);
  border: 2px solid var(--accent);
  padding: 10px;
  border-radius: 8px;
  font-size: 14px;
  cursor: pointer;
}

.board-container {
  background: var(--bg-secondary);
  padding: 10px;
  border-radius: 8px;
  box-shadow: 0 4px 16px var(--shadow);
  width: 100%;
  max-width: 460px;
  margin: 0 auto 15px;
  position: relative;
  touch-action: none;
  -webkit-user-select: none;
  user-select: none;
}

.board {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  grid-template-rows: repeat(4, 1fr);
  gap: 10px;
  width: 100%;
  aspect-ratio: 1;
  position: relative;
  background: var(--cell-bg);
  padding: 10px;
  border-radius: 8px;
}

.tile-container {
    position: absolute;
    inset: 10px;
}

.tile {
  position: absolute;
  width: calc(25% - 7.5px);
  height: calc(25% - 7.5px);
  background: var(--tile-bg);
  border-radius: 8px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 32px;
  font-weight: 700;
  color: var(--text-dark);
  transition: transform 0.1s linear;
  -webkit-user-select: none;
  user-select: none;
  border: 2px solid var(--bg-primary);
  box-shadow: 0 4px 8px var(--shadow), inset 0 -2px 0 rgba(0,0,0,0.05);
  z-index: 2;
  --x: 0;
  --y: 0;
  transform: translate(calc(var(--x) * (100% + 10px)), calc(var(--y) * (100% + 10px)));
}

.tile.new {
  animation: fadeIn 0.2s ease-in-out;
}

.tile.merged {
  animation: pop 0.2s ease-in-out;
}

@keyframes fadeIn {
  0% { transform: translate(calc(var(--x) * (100% + 10px)), calc(var(--y) * (100% + 10px))) scale(0.5); opacity: 0; }
  100% { transform: translate(calc(var(--x) * (100% + 10px)), calc(var(--y) * (100% + 10px))) scale(1); opacity: 1; }
}

@keyframes pop {
  0% { transform: translate(calc(var(--x) * (100% + 10px)), calc(var(--y) * (100% + 10px))) scale(0.8); }
  50% { transform: translate(calc(var(--x) * (100% + 10px)), calc(var(--y) * (100% + 10px))) scale(1.1); }
  100% { transform: translate(calc(var(--x) * (100% + 10px)), calc(var(--y) * (100% + 10px))) scale(1); }
}

.tile.v2 { background: var(--tile-2); }
.tile.v4 { background: var(--tile-4); }
.tile.v8 { background: var(--tile-8); color: var(--text-light); }
.tile.v16 { background: var(--tile-16); color: var(--text-light); }
.tile.v32 { background: var(--tile-32); color: var(--text-light); }
.tile.v64 { background: var(--tile-64); color: var(--text-light); }
.tile.v128 { background: var(--tile-128); color: var(--text-light); font-size: 28px; }
.tile.v256 { background: var(--tile-256); color: var(--text-light); font-size: 28px; }
.tile.v512 { background: var(--tile-512); color: var(--text-light); font-size: 28px; }
.tile.v1024 { background: var(--tile-1024); color: var(--text-light); font-size: 24px; }
.tile.v2048 { background: var(--tile-2048); color: var(--text-light); font-size: 24px; animation: pulse 1s infinite, pop 0.2s ease-in-out; }

@keyframes pulse {
  0%, 100% { box-shadow: 0 0 0 0 rgba(139, 115, 85, 0.7); }
  50% { box-shadow: 0 0 0 10px rgba(139, 115, 85, 0); }
}

.overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.8);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.overlay.active {
  display: flex;
}

.modal {
  background: var(--bg-primary);
  padding: 40px;
  border-radius: 16px;
  text-align: center;
  max-width: 90%;
  animation: slideUp 0.3s ease;
}

@keyframes slideUp {
  from { transform: translateY(50px); opacity: 0; }
  to { transform: translateY(0); opacity: 1; }
}

.modal h2 {
  font-size: 36px;
  margin-bottom: 20px;
  color: var(--accent);
}

.modal button {
  margin-top: 20px;
  font-size: 16px;
  padding: 12px 30px;
}

@media (max-width: 480px) {
  .tile {
    font-size: 24px;
  }
  
  .tile.v128, .tile.v256, .tile.v512 {
    font-size: 20px;
  }
  
  .tile.v1024, .tile.v2048 {
    font-size: 16px;
  }
}
</style>
</head>
<body>
<div class="container">
  <div class="header">
    <h1>2048</h1>
    <div class="score-container">
      <div class="score-box">
        –°—á—ë—Ç: <span class="score-value" id="score">0</span>
      </div>
      <div class="score-box">
        –õ—É—á—à–∏–π: <span class="score-value" id="best">0</span>
      </div>
    </div>
  </div>
  
  <div class="controls">
    <button id="new-game">–ù–æ–≤–∞—è –∏–≥—Ä–∞</button>
    <select id="theme-select">
      <option value="beige">–ë–µ–∂–µ–≤—ã–π</option>
      <option value="dark">–¢—ë–º–Ω—ã–π</option>
      <option value="ocean">–û–∫–µ–∞–Ω</option>
      <option value="forest">–õ–µ—Å</option>
    </select>
  </div>
  
  <div class="board-container">
    <div class="board"></div>
    <div class="tile-container" id="tile-container"></div>
  </div>
</div>

<div class="overlay" id="game-over">
  <div class="modal">
    <h2>–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞!</h2>
    <p>–§–∏–Ω–∞–ª—å–Ω—ã–π —Å—á—ë—Ç: <span id="final-score">0</span></p>
    <button id="restart">–ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞</button>
  </div>
</div>

<div class="overlay" id="victory">
  <div class="modal">
    <h2>üéâ –ü–æ–±–µ–¥–∞! üéâ</h2>
    <p>–í—ã —Å–æ–±—Ä–∞–ª–∏ 2048!</p>
    <p>–°—á—ë—Ç: <span id="victory-score">0</span></p>
    <button id="continue">–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å</button>
  </div>
</div>

<script>
// ==================== –ö–û–ù–°–¢–ê–ù–¢–´ –ò –ü–ï–†–ï–ú–ï–ù–ù–´–ï ====================
const BOARD_SIZE = 4;
const boardContainer = document.getElementById('board');
const tileContainer = document.getElementById('tile-container');
const scoreEl = document.getElementById('score');
const bestEl = document.getElementById('best');
const newGameBtn = document.getElementById('new-game');
const themeSelect = document.getElementById('theme-select');
const gameOverOverlay = document.getElementById('game-over');
const victoryOverlay = document.getElementById('victory');
const finalScoreEl = document.getElementById('final-score');
const victoryScoreEl = document.getElementById('victory-score');

let grid = [];
let tiles = [];
let score = 0;
let best = parseInt(localStorage.getItem('bestScore') || '0', 10);
let hasWon = false;

bestEl.textContent = best;

// ==================== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ====================
function initGrid() {
  grid = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0));
  tiles = [];
}

function addRandomTile() {
  const emptyCells = [];
  for (let r = 0; r < BOARD_SIZE; r++) {
    for (let c = 0; c < BOARD_SIZE; c++) {
      if (grid[r][c] === 0) emptyCells.push({ r, c });
    }
  }

  if (emptyCells.length === 0) return false;

  const { r, c } = emptyCells[Math.floor(Math.random() * emptyCells.length)];
  const value = Math.random() < 0.9 ? 2 : 4;
  const newTile = { value, r, c, id: Date.now() };
  grid[r][c] = value;
  tiles.push(newTile);
  return true;
}

// ==================== –†–ï–ù–î–ï–†–ò–ù–ì ====================
function render() {
    tileContainer.innerHTML = '';
    tiles.forEach(tile => {
        if (!tile) return;
        const tileEl = document.createElement('div');
        tileEl.className = 'tile';
        tileEl.classList.add(`v${tile.value}`);
        tileEl.style.setProperty('--x', tile.c);
        tileEl.style.setProperty('--y', tile.r);
        tileEl.textContent = tile.value;
        tileEl.dataset.id = tile.id;

        if (tile.merged) {
            tileEl.classList.add('merged');
        }
        if (tile.isNew) {
            tileEl.classList.add('new');
        }
        
        tileContainer.appendChild(tileEl);
    });

    tiles = tiles.map(t => t ? {...t, isNew: false, merged: false} : null).filter(Boolean);
    updateScore();
}

// ==================== –õ–û–ì–ò–ö–ê –î–í–ò–ñ–ï–ù–ò–Ø ====================
function move(direction) {
  let moved = false;
  let newScore = 0;
  const newTiles = [];
  
  const moveVector = {
    up: { r: -1, c: 0 },
    down: { r: 1, c: 0 },
    left: { r: 0, c: -1 },
    right: { r: 0, c: 1 },
  }[direction];

  const traversal = {
    up: { r: [...Array(BOARD_SIZE).keys()], c: [...Array(BOARD_SIZE).keys()] },
    down: { r: [...Array(BOARD_SIZE).keys()].reverse(), c: [...Array(BOARD_SIZE).keys()] },
    left: { r: [...Array(BOARD_SIZE).keys()], c: [...Array(BOARD_SIZE).keys()] },
    right: { r: [...Array(BOARD_SIZE).keys()], c: [...Array(BOARD_SIZE).keys()].reverse() },
  }[direction];

  const tempGrid = JSON.parse(JSON.stringify(grid));
  
  traversal.r.forEach(r => {
    traversal.c.forEach(c => {
        if (tempGrid[r][c] === 0) return;

        let currentR = r;
        let currentC = c;
        let nextR, nextC;

        do {
            nextR = currentR + moveVector.r;
            nextC = currentC + moveVector.c;

            if (nextR < 0 || nextR >= BOARD_SIZE || nextC < 0 || nextC >= BOARD_SIZE) break;
            if (tempGrid[nextR][nextC] !== 0) break;

            currentR = nextR;
            currentC = nextC;
        } while (true);
        
        if (currentR !== r || currentC !== c) {
            tempGrid[currentR][currentC] = tempGrid[r][c];
            tempGrid[r][c] = 0;
            moved = true;
        }

        const nextMergeR = currentR + moveVector.r;
        const nextMergeC = currentC + moveVector.c;

        if (nextMergeR >= 0 && nextMergeR < BOARD_SIZE && nextMergeC >= 0 && nextMergeC < BOARD_SIZE) {
            if (tempGrid[nextMergeR][nextMergeC] === tempGrid[currentR][currentC]) {
                tempGrid[nextMergeR][nextMergeC] *= 2;
                newScore += tempGrid[nextMergeR][nextMergeC];
                tempGrid[currentR][currentC] = 0;
                moved = true;
            }
        }
    });
  });

  if (moved) {
    grid = tempGrid;
    tiles = [];
    for(let r = 0; r < BOARD_SIZE; r++) {
        for(let c = 0; c < BOARD_SIZE; c++) {
            if(grid[r][c] !== 0) {
                 const newTile = { value: grid[r][c], r, c, id: Date.now() + r * BOARD_SIZE + c };
                 const oldTile = tiles.find(t => t && t.r === r && t.c === c);
                 if(oldTile && oldTile.value !== newTile.value) {
                     newTile.merged = true;
                 }
                 tiles.push(newTile);
            }
        }
    }
    score += newScore;
  }

  return moved;
}

// ==================== –ü–†–û–í–ï–†–ö–ò –°–û–°–¢–û–Ø–ù–ò–Ø ====================
function canMove() {
  for (let r = 0; r < BOARD_SIZE; r++) {
    for (let c = 0; c < BOARD_SIZE; c++) {
      if (grid[r][c] === 0) return true;
      if (c < BOARD_SIZE - 1 && grid[r][c] === grid[r][c + 1]) return true;
      if (r < BOARD_SIZE - 1 && grid[r][c] === grid[r + 1][c]) return true;
    }
  }
  return false;
}

function checkWin() {
  if (hasWon) return false;
  const has2048 = tiles.some(tile => tile && tile.value === 2048);
  if (has2048) {
    hasWon = true;
    victoryScoreEl.textContent = score;
    victoryOverlay.classList.add('active');
    return true;
  }
  return false;
}

// ==================== –£–ü–†–ê–í–õ–ï–ù–ò–ï –ò–ì–†–û–ô ====================
function handleMove(direction) {
  if (!canMove()) return;
  
  const moved = move(direction);

  if (moved) {
    const newTileAdded = addRandomTile();
    if(newTileAdded){
      const lastTile = tiles[tiles.length - 1];
      if (lastTile) lastTile.isNew = true;
    }
    
    render();
    checkWin();

    if (!canMove()) {
      setTimeout(() => {
        finalScoreEl.textContent = score;
        gameOverOverlay.classList.add('active');
        saveBestScore();
      }, 500);
    }
  }
}

function updateScore() {
  scoreEl.textContent = score;
  if (score > best) {
    best = score;
    bestEl.textContent = best;
  }
}

function saveBestScore() {
  if (score > best) {
    localStorage.setItem('bestScore', best);
  }
}

function newGame() {
  score = 0;
  hasWon = false;
  updateScore();
  gameOverOverlay.classList.remove('active');
  victoryOverlay.classList.remove('active');
  initGrid();
  addRandomTile();
  addRandomTile();
  tiles.forEach(t => t.isNew = true);
  render();
}

// ==================== –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –°–û–ë–´–¢–ò–ô ====================
document.addEventListener('keydown', (e) => {
  if (e.key === 'ArrowUp') handleMove('up');
  if (e.key === 'ArrowDown') handleMove('down');
  if (e.key === 'ArrowLeft') handleMove('left');
  if (e.key === 'ArrowRight') handleMove('right');
});

let touchStartX = 0;
let touchStartY = 0;
let isSwipeInProgress = false;

document.addEventListener('touchstart', (e) => {
  if (e.target.closest('.board-container')) {
    isSwipeInProgress = true;
    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
    e.preventDefault();
  }
}, { passive: false });

document.addEventListener('touchend', (e) => {
  if (!isSwipeInProgress) return;
  isSwipeInProgress = false;
  
  const touchEndX = e.changedTouches[0].clientX;
  const touchEndY = e.changedTouches[0].clientY;
  
  const dx = touchEndX - touchStartX;
  const dy = touchEndY - touchStartY;
  const absDx = Math.abs(dx);
  const absDy = Math.abs(dy);
  
  if (Math.max(absDx, absDy) > 30) {
    if (absDx > absDy) {
      handleMove(dx > 0 ? 'right' : 'left');
    } else {
      handleMove(dy > 0 ? 'down' : 'up');
    }
  }
}, { passive: false });

document.addEventListener('touchmove', (e) => {
  if (isSwipeInProgress) {
    e.preventDefault();
  }
}, { passive: false });

themeSelect.addEventListener('change', (e) => {
  const theme = e.target.value;
  document.body.className = theme === 'beige' ? '' : `theme-${theme}`;
  localStorage.setItem('theme', theme);
});

const savedTheme = localStorage.getItem('theme') || 'beige';
if (savedTheme !== 'beige') {
  document.body.className = `theme-${savedTheme}`;
  themeSelect.value = savedTheme;
}

newGameBtn.addEventListener('click', newGame);
document.getElementById('restart').addEventListener('click', newGame);
document.getElementById('continue').addEventListener('click', () => {
  victoryOverlay.classList.remove('active');
});

// ==================== –ó–ê–ü–£–°–ö –ò–ì–†–´ ====================
newGame();
</script>
</body>
</html>
